<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Cuneyt Yildirim Site</title>
    <link>//localhost:1313/posts/</link>
    <description>Recent content in Posts on Cuneyt Yildirim Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 12 Jan 2025 15:50:48 -0500</lastBuildDate><atom:link href="//localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sorting Algorithms</title>
      <link>//localhost:1313/posts/algorithms/sorting/</link>
      <pubDate>Sun, 12 Jan 2025 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/sorting/</guid>
      <description>&lt;h1 id=&#34;sorting-algorithms&#34;&gt;Sorting Algorithms&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@agustin.ignacio.rossi/coding-interviews-preparation-sorting-algorithms-fdc1dc51e4a1%3E%27&#34;&gt;Based on Agustin Ignacio Rossi article&lt;/a&gt;&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;sorting-algorithms&#34;&gt;Sorting Algorithms&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@agustin.ignacio.rossi/coding-interviews-preparation-sorting-algorithms-fdc1dc51e4a1%3E%27&#34;&gt;Based on Agustin Ignacio Rossi article&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/bubblesort/&#34;&gt;Bubble Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/selectionsort/&#34;&gt;Selection Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/insertionsort/&#34;&gt;Insertion Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/mergesort/&#34;&gt;Merge Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/quicksort/&#34;&gt;Quick Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/radixsort/&#34;&gt;Radix Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//localhost:1313/posts/algorithms/recursivebubblesort/&#34;&gt;Recursive Bubble Sort&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
    </item>
    
    <item>
      <title>Initial</title>
      <link>//localhost:1313/posts/initial/</link>
      <pubDate>Sun, 12 Jan 2025 02:38:44 -0500</pubDate>
      
      <guid>//localhost:1313/posts/initial/</guid>
      <description></description>
      <content></content>
    </item>
    
    <item>
      <title>BubbleSort</title>
      <link>//localhost:1313/posts/algorithms/bubblesort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/bubblesort/</guid>
      <description>&lt;h2 id=&#34;bubble-sort&#34;&gt;Bubble Sort&lt;/h2&gt;</description>
      <content>&lt;h2 id=&#34;bubble-sort&#34;&gt;Bubble Sort&lt;/h2&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;select the first element of the array&lt;/li&gt;
&lt;li&gt;compare it with its next element&lt;/li&gt;
&lt;li&gt;if it is larger than the next element then swap them&lt;/li&gt;
&lt;li&gt;else do nothing&lt;/li&gt;
&lt;li&gt;keep doing this for every index of the array&lt;/li&gt;
&lt;li&gt;repeat the above process n times.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BubbleSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbleSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; swapped;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            swapped &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;// Swap elements&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    swapped &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;swapped) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Optimized - stop if no swaps&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Best case: O(n) (already sorted)&lt;/li&gt;
&lt;li&gt;Worst case: O(n2)&lt;/li&gt;
&lt;li&gt;Space complexity: O(1) (in-place sorting)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr[] = {10, 80, 40, 30}
Indexes: 0   1   2   3

1. Index = 0, Number = 10
2. 10 &amp;lt; 80, do nothing and continue

3. Index = 1, Number = 80
4. 80 &amp;gt; 40, swap 80 and 40
5. The array now is {10, 40, 80, 30}

6. Index = 2, Number = 80
7. 80 &amp;gt; 30, swap 80 and 30
8. The array now is {10, 40, 30, 80}

Repeat the Above Steps again

arr[] = {10, 40, 30, 80}
Indexes: 0   1   2   3

1. Index = 0, Number = 10
2. 10 &amp;lt; 40, do nothing and continue

3. Index = 1, Number = 40
4. 40 &amp;gt; 30, swap 40 and 30
5. The array now is {10, 30, 40, 80}

6. Index = 2, Number = 40
7. 40 &amp;lt; 80, do nothing
8. The array now is {10, 30, 40, 80}

Repeat the Above Steps again

arr[] = {10, 30, 40, 80}
Indexes: 0   1   2   3

1. Index = 0, Number = 10
2. 10 &amp;lt; 30, do nothing and continue

3. Index = 1, Number = 30
4. 30 &amp;lt; 40, do nothing and continue

5. Index = 2, Number = 40
6. 40 &amp;lt; 80, do nothing

Since there are no swaps in above steps, it means the array is sorted and we can stop here.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/sorts/bubble_sort.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/Sorters/Comparison/BubbleSorter.cs&#34;&gt;C-Sharp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Go/blob/master/sorts/bubblesort.go&#34;&gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/BubbleSort.js&#34;&gt;Javascript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Jdtq5uKz-w4&#34;&gt;A video explaining the Bubble Sort Algorithm&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;others&#34;&gt;Others&lt;/h4&gt;
&lt;p&gt;Bubble sort is also known as Sinking sort.&lt;/p&gt;
&lt;h4 id=&#34;animation-explanation&#34;&gt;Animation Explanation&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boardhub.github.io/tute/?wd=bubbleSortAlgo2&#34;&gt;Tute Board&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    </item>
    
    <item>
      <title>BubbleSort</title>
      <link>//localhost:1313/posts/algorithms/heapsort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/heapsort/</guid>
      <description>&lt;h1 id=&#34;heap-sort&#34;&gt;Heap Sort&lt;/h1&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given an unsorted array of n elements, write a function to sort the array&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Build a max heap from the input data.&lt;/li&gt;
&lt;li&gt;At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.&lt;/li&gt;
&lt;li&gt;Repeat above steps while size of heap is greater than 1.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;O(n log n)&lt;/code&gt; Worst case performance&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;heap-sort&#34;&gt;Heap Sort&lt;/h1&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given an unsorted array of n elements, write a function to sort the array&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Build a max heap from the input data.&lt;/li&gt;
&lt;li&gt;At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.&lt;/li&gt;
&lt;li&gt;Repeat above steps while size of heap is greater than 1.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;O(n log n)&lt;/code&gt; Worst case performance&lt;/p&gt;
&lt;p&gt;&lt;code&gt;O(n log n)&lt;/code&gt; (distinct keys)
or O(n) (equal keys) Best-case performance&lt;/p&gt;
&lt;p&gt;&lt;code&gt;O(n log n)&lt;/code&gt; Average performance&lt;/p&gt;
&lt;h4 id=&#34;space-complexity&#34;&gt;Space Complexity&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; Worst case auxiliary&lt;/p&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input data: 4, 10, 3, 5, 1
        4(0)
       /   \
    10(1)   3(2)
   /   \
5(3)    1(4)

The numbers in bracket represent the indices in the array
representation of data.

Applying heapify procedure to index 1:
        4(0)
       /   \
   10(1)    3(2)
   /   \
5(3)    1(4)

Applying heapify procedure to index 0:
       10(0)
       /  \
    5(1)  3(2)
   /   \
4(3)    1(4)
The heapify procedure calls itself recursively to build heap
in top down manner.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif&#34; alt=&#34;heap-image&#34; title=&#34;Heap Sort&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Sorts/HeapSort.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/sorts/heap_sort.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Go/blob/master/sorts/heapsort.go&#34;&gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/Sorters/Comparison/HeapSorter.cs&#34;&gt;C-sharp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/HeapSort.js&#34;&gt;Javascript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=MtQL_ll5KhQ&#34;&gt;A video explaining the Heap Sort Algorithm&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>InsertionSort</title>
      <link>//localhost:1313/posts/algorithms/insertionsort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/insertionsort/</guid>
      <description>&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort&lt;/h2&gt;
&lt;p&gt;Insertion Sort builds the sorted array one element at a time by repeatedly picking the next element and inserting it into the correct position in the sorted portion.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort&lt;/h2&gt;
&lt;p&gt;Insertion Sort builds the sorted array one element at a time by repeatedly picking the next element and inserting it into the correct position in the sorted portion.&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Define a &amp;ldquo;key&amp;rdquo; index, the subarray to the left of which is sorted.&lt;/li&gt;
&lt;li&gt;Initiate &amp;ldquo;key&amp;rdquo; as 1, ie. the second element of array(as there is only one element to left of the second element, which can be considered as sorted array with one element).&lt;/li&gt;
&lt;li&gt;If value of element at (key - 1) position is less than value of element at (key) position; increment &amp;ldquo;key&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Else move elements of sorted subarray that are greater than value of element at &amp;ldquo;key&amp;rdquo; to one position ahead of their current position. Put the value of element at &amp;ldquo;key&amp;rdquo; in the newly created void.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;InsertionSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;insertionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; key) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                j&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Best case: O(n) (nearly sorted)&lt;/li&gt;
&lt;li&gt;Worst case: O(n2)&lt;/li&gt;
&lt;li&gt;Space complexity: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
12, 11, 13, 5, 6

Let us loop for i = 1 (second element of the array) to 4 (Size of input array)

i = 1.
Since 11 is smaller than 12, move 12 and insert 11 before 12
11, 12, 13, 5, 6

i = 2.
13 will remain at its position as all elements in sorted subarray are smaller than 13
11, 12, 13, 5, 6

i = 3.
5 will move to the beginning,
and all other elements from 11 to 13 will move one position ahead of their current position.
5, 11, 12, 13, 6

i = 4.
6 will move to position after 5,
and elements from 11 to 13 will move one position ahead of their current position.
5, 6, 11, 12, 13  -- sorted array
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Sorts/InsertionSort.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/Sorters/Comparison/InsertionSorter.cs&#34;&gt;C#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/sorts/insertion_sort.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=DFG-XuyPYUQ&#34;&gt;A CS50 video explaining the Insertion Search Algorithm&lt;/a&gt;&lt;/p&gt;</content>
    </item>
    
    <item>
      <title>MergeSort</title>
      <link>//localhost:1313/posts/algorithms/mergesort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/mergesort/</guid>
      <description>&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort&lt;/h2&gt;
&lt;p&gt;Merge Sort is a divide-and-conquer algorithm that splits the array into halves, recursively sorts each half, and then merges the sorted halves.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort&lt;/h2&gt;
&lt;p&gt;Merge Sort is a divide-and-conquer algorithm that splits the array into halves, recursively sorts each half, and then merges the sorted halves.&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Find a mid point and divide the array into to halves based on the mid point&lt;/li&gt;
&lt;li&gt;Recursively call the merge sort function for both the halves&lt;/li&gt;
&lt;li&gt;Merge the two sorted halves to get the sorted array&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MergeSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mergeSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 2) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;mid&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; mid&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;arraycopy&lt;/span&gt;(array, 0, left, 0, mid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;arraycopy&lt;/span&gt;(array, mid, right, 0, array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; mid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mergeSort(left);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mergeSort(right);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        merge(array, left, right);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; right) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (left&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Best/Worst/Average case: O(n log ⁡n)&lt;/li&gt;
&lt;li&gt;Space complexity: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr = [1, 3, 9, 5, 0, 2]

Divide the array in two halves [1, 3, 9] and [5, 0, 2]

Recursively call merge sort function for both these halves which will provide sorted halves
=&amp;gt; [1, 3, 9] &amp;amp; [0, 2, 5]

Now merge both these halves to get the sorted array [0, 1, 2, 3, 5, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;example-2&#34;&gt;Example 2&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr = [1, 9, 2, 5, 7, 3, 6, 4]

Divide the array into two halves [1, 9, 2, 5] and [7, 3, 6, 4]

As you can see that the above two halves are not yet sorted, so divide both of them into two halves again.

This time we get four arrays as [1, 9], [2, 5], [7, 3] and [6, 4].

We see that the last two arrays are again not sorted, so we divide them again into two halves and we will get [7], [3], [6], and [4].

Since an array of a single element is sorted, we now have all the arrays sorted, now we only need to merge them appropriately.

First, the arrays of one element will be merged as they were divided in last, and are at top of the recursion stack, so we get [3,7] and [4,6].

Now the merge will occur accordingly to the recursion stack, [1, 9] and [2, 5] will be merged and will make [1, 2, 5, 9].

Similarly [3, 7] and [4, 6] will be merged and made [3, 4, 6, 7].

At the next stack level [1, 2, 5, 9] and [3, 4, 6, 7] will be merged and we will get the final sorted array as [1, 2, 3, 4, 5, 6, 7, 9].
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Sorts/MergeSort.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/sorts/merge_sort.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/Sorters/Comparison/MergeSorter.cs&#34;&gt;C-Sharp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=EeQ8pwjQxTM&#34;&gt;A CS50 video explaining the Merge Sort Algorithm&lt;/a&gt;&lt;/p&gt;</content>
    </item>
    
    <item>
      <title>QuickSort</title>
      <link>//localhost:1313/posts/algorithms/quicksort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/quicksort/</guid>
      <description>&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h2&gt;
&lt;p&gt;Quick Sort selects a “pivot” element and partitions the array so that all elements smaller than the pivot are on one side, and all larger elements are on the other. It then recursively sorts the subarrays.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h2&gt;
&lt;p&gt;Quick Sort selects a “pivot” element and partitions the array so that all elements smaller than the pivot are on one side, and all larger elements are on the other. It then recursively sorts the subarrays.&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Make the right-most index value pivot&lt;/li&gt;
&lt;li&gt;partition the array using pivot value&lt;/li&gt;
&lt;li&gt;quicksort left partition recursively&lt;/li&gt;
&lt;li&gt;quicksort right partition recursively&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QuickSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;quickSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (low &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pivotIndex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; partition(array, low, high);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            quickSort(array, low, pivotIndex &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            quickSort(array, pivotIndex &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, high);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;partition&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pivot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;high&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; low &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; low; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; high; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; pivot) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;high&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;high&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Best/Average case: O(n log ⁡n)&lt;/li&gt;
&lt;li&gt;Worst case: O(n²)(poor pivot choice)&lt;/li&gt;
&lt;li&gt;Space complexity: O(log⁡ n) (recursion stack)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr[] = {10, 80, 30, 90, 40, 50, 70}
Indexes:  0   1   2   3   4   5   6

low = 0, high =  6, pivot = arr[h] = 70
Initialize index of smaller element, i = -1

Traverse elements from j = low to high-1
j = 0 : Since arr[j] &amp;lt;= pivot, do i++ and swap(arr[i], arr[j])
i = 0
arr[] = {10, 80, 30, 90, 40, 50, 70} // No change as i and j
                                     // are same

j = 1 : Since arr[j] &amp;gt; pivot, do nothing
// No change in i and arr[]

j = 2 : Since arr[j] &amp;lt;= pivot, do i++ and swap(arr[i], arr[j])
i = 1
arr[] = {10, 30, 80, 90, 40, 50, 70} // We swap 80 and 30

j = 3 : Since arr[j] &amp;gt; pivot, do nothing
// No change in i and arr[]

j = 4 : Since arr[j] &amp;lt;= pivot, do i++ and swap(arr[i], arr[j])
i = 2
arr[] = {10, 30, 40, 90, 80, 50, 70} // 80 and 40 Swapped
j = 5 : Since arr[j] &amp;lt;= pivot, do i++ and swap arr[i] with arr[j]
i = 3
arr[] = {10, 30, 40, 50, 80, 90, 70} // 90 and 50 Swapped

We come out of loop because j is now equal to high-1.
Finally we place pivot at correct position by swapping
arr[i+1] and arr[high] (or pivot)
arr[] = {10, 30, 40, 50, 70, 90, 80} // 80 and 70 Swapped

Now 70 is at its correct place. All elements smaller than
70 are before it and all elements greater than 70 are after
it.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Sorts/QuickSort.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/sorts/quick_sort.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=COk73cpQbFQ&#34;&gt;A video explaining the Quick Sort Algorithm&lt;/a&gt;&lt;/p&gt;</content>
    </item>
    
    <item>
      <title>Radix Sort</title>
      <link>//localhost:1313/posts/algorithms/radixsort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/radixsort/</guid>
      <description>&lt;h1 id=&#34;radix-sort&#34;&gt;Radix Sort&lt;/h1&gt;
&lt;p&gt;The lower bound for Comparison based sorting algorithm (Merge Sort, Heap Sort, Quick-Sort .. etc) is &lt;code&gt;Ω(nlogn)&lt;/code&gt;, i.e., they cannot do better than &lt;code&gt;nlogn&lt;/code&gt;.&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;radix-sort&#34;&gt;Radix Sort&lt;/h1&gt;
&lt;p&gt;The lower bound for Comparison based sorting algorithm (Merge Sort, Heap Sort, Quick-Sort .. etc) is &lt;code&gt;Ω(nlogn)&lt;/code&gt;, i.e., they cannot do better than &lt;code&gt;nlogn&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Counting sort is a linear time sorting algorithm that sort in &lt;code&gt;O(n+k)&lt;/code&gt; time when elements are in the range from 1 to k.&lt;/p&gt;
&lt;p&gt;What if the elements are in the range from 1 to n2? We can’t use counting sort because counting sort will take &lt;code&gt;O(n2)&lt;/code&gt; which is worse than comparison-based sorting algorithms. Can we sort such an array in linear time?&lt;/p&gt;
&lt;p&gt;Radix Sort is the answer. The idea of Radix Sort is to do digit by digit sort starting from least significant digit to most significant digit. Radix sort uses counting sort as a subroutine to sort.&lt;/p&gt;
&lt;h2 id=&#34;the-radix-sort-algorithm&#34;&gt;The Radix Sort Algorithm&lt;/h2&gt;
&lt;p&gt;Do following for each digit i where i varies from least significant digit to the most significant digit.
Sort input array using counting sort (or any stable sort) according to the i’th digit.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Original, unsorted list:
&lt;code&gt;170, 45, 75, 90, 802, 24, 2, 66&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Sorting by least significant digit (1s place) gives:&lt;/p&gt;
&lt;p&gt;[*Notice that we keep 802 before 2, because 802 occurred
before 2 in the original list, and similarly for pairs
170 &amp;amp; 90 and 45 &amp;amp; 75.]&lt;/p&gt;
&lt;p&gt;Sorting by next digit (10s place) gives:&lt;/p&gt;
&lt;p&gt;[*Notice that 802 again comes before 2 as 802 comes before 2 in the previous list.]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;802, 2, 24, 45, 66, 170, 75, 90&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Sorting by the most significant digit (100s place) gives:
&lt;code&gt;2, 24, 45, 66, 75, 90, 170, 802&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;what-is-the-running-time-of-radix-sort&#34;&gt;What is the running time of Radix Sort?&lt;/h2&gt;
&lt;p&gt;Let there be d digits in input integers. Radix Sort takes &lt;code&gt;O(d*(n+b))&lt;/code&gt; time where b is the base for representing numbers, for example, for the decimal system, b is 10.
What is the value of d? If &lt;code&gt;k&lt;/code&gt; is the maximum possible value, then d would be &lt;code&gt;O(logb(k))&lt;/code&gt;. So overall time complexity is &lt;code&gt;O((n+b) * logb(k))&lt;/code&gt;. Which looks more than the
time complexity of comparison-based sorting algorithms for a large k. Let us first limit k. Let k &amp;lt;= nc where c is a constant. In that case, the complexity becomes
&lt;code&gt;O(n logb(n))&lt;/code&gt;. But it still doesn’t beat comparison-based sorting algorithms.&lt;/p&gt;
&lt;h2 id=&#34;is-radix-sort-preferable-to-comparison-based-sorting-algorithms-like-quick-sort&#34;&gt;Is Radix Sort preferable to Comparison based sorting algorithms like Quick-Sort?&lt;/h2&gt;
&lt;p&gt;If we have &lt;code&gt;log2n&lt;/code&gt; bits for every digit, the running time of Radix appears to be better than Quick Sort for a wide range of input numbers. The constant factors hidden in
asymptotic notation are higher for Radix Sort and Quick-Sort uses hardware caches more effectively. Also, Radix sort uses counting sort as a subroutine and counting sort
takes extra space to sort numbers.&lt;/p&gt;
&lt;p&gt;Video reference: &lt;a href=&#34;https://youtu.be/nu4gDuFabIM&#34;&gt;https://youtu.be/nu4gDuFabIM&lt;/a&gt;&lt;/p&gt;</content>
    </item>
    
    <item>
      <title>Recursive Bubble Sort</title>
      <link>//localhost:1313/posts/algorithms/recursivebubblesort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/recursivebubblesort/</guid>
      <description>&lt;h1 id=&#34;recursive-bubble-sort&#34;&gt;Recursive Bubble Sort&lt;/h1&gt;
&lt;p&gt;Bubble Sort is one of the simplest sorting algorithms that compares two elements at a time and swaps them if they are in the wrong order. This process is repeated until the entire sequence is in order.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Time Complexity: &lt;code&gt;O(n ^ 2)&lt;/code&gt; for average case; &lt;code&gt;O(n)&lt;/code&gt; for best case.&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;code&gt;O(n)&lt;/code&gt;; note that iterative bubble sort has space complexity as &lt;code&gt;O(1)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;
&lt;p&gt;Base case: If the size of the array is 1, return.&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;recursive-bubble-sort&#34;&gt;Recursive Bubble Sort&lt;/h1&gt;
&lt;p&gt;Bubble Sort is one of the simplest sorting algorithms that compares two elements at a time and swaps them if they are in the wrong order. This process is repeated until the entire sequence is in order.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Time Complexity: &lt;code&gt;O(n ^ 2)&lt;/code&gt; for average case; &lt;code&gt;O(n)&lt;/code&gt; for best case.&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;code&gt;O(n)&lt;/code&gt;; note that iterative bubble sort has space complexity as &lt;code&gt;O(1)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;
&lt;p&gt;Base case: If the size of the array is 1, return.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We need to fix the last element of the current sub-array. For this, iterate over the entire array using normal Bubble Sort, and perform swapping.&lt;/li&gt;
&lt;li&gt;Next, call the function on the entire array excluding the last element(which was fixed by the iteration in the above step)&lt;/li&gt;
&lt;li&gt;Repeat until Base Case is reached.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;Let the given array be: &lt;code&gt;{5, 3, 2, 1, 4}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First Iteration:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{&lt;code&gt;5&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, 2, 1, 4} -&amp;gt; {&lt;code&gt;3&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, 2, 1, 4} Swap since &lt;code&gt;5 &amp;gt; 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{3, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, 1, 4} -&amp;gt; {3, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, 1, 4} Swap since &lt;code&gt;5 &amp;gt; 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{3, 2, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, 4} -&amp;gt; {3, 2, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, 4} Swap since &lt;code&gt;5 &amp;gt; 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{3, 2, 1, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;} -&amp;gt; {3, 2, 1, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;} Swap since &lt;code&gt;5 &amp;gt; 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This iteration has fixed the position of 5. Now, we will consider the array up to index 3.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second Iteration:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{&lt;code&gt;3&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, 1, 4, 5} -&amp;gt; {&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, 1, 4, 5} Swap since &lt;code&gt;3 &amp;gt; 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{2, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, 4, 5} -&amp;gt; {2, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, 4, 5} Swap since &lt;code&gt;3 &amp;gt; 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{2, 1, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, 5}; As &lt;code&gt;3 &amp;lt; 4&lt;/code&gt;, do not swap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: As we check one less element with every iteration, we do not need elements at index 3 and 4 i.e., &lt;code&gt;4&lt;/code&gt; and &lt;code&gt;5&lt;/code&gt;, as 5 is already in order. Formally, for an array with &lt;code&gt;n&lt;/code&gt; integers, we consider elements only up to index &lt;code&gt;n - i&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the iteration number.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Third Iteration:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, 3, 4, 5} -&amp;gt; {&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, 3, 4, 5} Swap since &lt;code&gt;1 &amp;gt; 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{1, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, 4, 5}; As &lt;code&gt;2 &amp;lt; 3&lt;/code&gt;, do not swap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Fourth Iteration:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, 3, 4, 5}; As &lt;code&gt;1 &amp;lt; 2&lt;/code&gt;, do not swap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Fifth Iteration:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{&lt;code&gt;1&lt;/code&gt;, 2, 3, 4, 5}; As the size of the array is 1, return.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: This is the base case.&lt;/p&gt;
&lt;h2 id=&#34;pseudo-code&#34;&gt;Pseudo Code&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void bubbleSort(arr[], n)
    if(n==1)
        return;

    for(i = 0; i&amp;lt;n-1; i++)
        if(arr[i] &amp;gt; arr[i+1])
            swap(arr[i], arr[i+1])

    bubbleSort(arr, n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;implementations&#34;&gt;Implementations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Sorts/BubbleSortRecursion.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C/blob/master/sorting/bubble_sort_recursion.c&#34;&gt;C&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gDMDVLBfCI0&#34;&gt;A video explaining iterative as well as recursive bubble sort&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>SelectionSort</title>
      <link>//localhost:1313/posts/algorithms/selectionsort/</link>
      <pubDate>Thu, 12 Dec 2024 15:50:48 -0500</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/selectionsort/</guid>
      <description>&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort&lt;/h2&gt;
&lt;p&gt;Selection Sort divides the array into sorted and unsorted parts. It repeatedly selects the smallest (or largest) element from the unsorted part and moves it to the sorted part.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort&lt;/h2&gt;
&lt;p&gt;Selection Sort divides the array into sorted and unsorted parts. It repeatedly selects the smallest (or largest) element from the unsorted part and moves it to the sorted part.&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;select the smallest element from the array&lt;/li&gt;
&lt;li&gt;put it at the beginning of the array&lt;/li&gt;
&lt;li&gt;then select the smallest array from the remaining unsorted list&lt;/li&gt;
&lt;li&gt;append it to the sorted array at the beginning&lt;/li&gt;
&lt;li&gt;keep doing this for every element of the array&lt;/li&gt;
&lt;li&gt;repeat the above process n times&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SelectionSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;selectionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; array) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; minIndex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;minIndex&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    minIndex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// Swap the found minimum element with the first element&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;minIndex&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;minIndex&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            array&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Best/Worst/Average case: O(n2)&lt;/li&gt;
&lt;li&gt;Space complexity: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr[] = {80, 10, 40, 30}
Indexes: 0   1   2   3

1. Index = 0
 Select the minimum number from the array (between index 0-3), ie, 10
2. Swap 10  and 80 (arr[0])
3. The array now is {10, 80, 40, 30}

4. Index = 1
 Select the minimum number from the array (between index 1-3), ie, 30
5. Swap 30 and 80 (arr[1])
6. The array now is {10, 30, 40, 80}

7. Index = 2
 Select the minimum number from the array (between index 2-3), ie, 40
8. Swap 40 and 40 (arr[2])
9. The array now is {10, 30, 40, 80}

The array is now sorted.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Sorts/SelectionSort.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/sorts/selection_sort.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Go/blob/master/sorts/selection_sort.go&#34;&gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/selectionSort.js&#34;&gt;Javascript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=f8hXR_Hvybo&#34;&gt;A video explaining the Selection Sort Algorithm&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;animation-explanation&#34;&gt;Animation Explanation&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boardhub.github.io/tute/?wd=selectSortAlgo2&#34;&gt;Tute Board&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/binary-search/</guid>
      <description>&lt;h1 id=&#34;binary-search-a-divide-and-conquer-algorithm&#34;&gt;Binary Search (A divide and conquer algorithm)&lt;/h1&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given a sorted  array of n elements, write a function to search for the index of a given element (target)&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Search for the array by dividing the array in half repeatedly.&lt;/li&gt;
&lt;li&gt;Initially consider the actual array and pick the element at the middle index&lt;/li&gt;
&lt;li&gt;Keep a lower index i.e. 0 and higher index i.e. length of array&lt;/li&gt;
&lt;li&gt;If it is equal to the target element then return the index&lt;/li&gt;
&lt;li&gt;Else if it is greater than the target element then consider only the left half of array. (lower index = 0, higher = middle - 1)&lt;/li&gt;
&lt;li&gt;Else if it is less than the target element then consider only the right half of array. (lower index = middle + 1, higher = length of array)&lt;/li&gt;
&lt;li&gt;Return -(insertion index + 1) if the target element is not found in the array (If the lower index is greater than or equal to higher index). Some simpler implementations just return -1 if the element is not found. The offset of 1 must be added as the insertion index might be 0 (the searched value might be smaller than all elements in the array). As indexing starts at 0, this must be distinguishable from the case where the target element has the index 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;O(log n) Worst Case  &lt;br&gt;
O(1) Best Case (If middle element of initial array is the target element)&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;binary-search-a-divide-and-conquer-algorithm&#34;&gt;Binary Search (A divide and conquer algorithm)&lt;/h1&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given a sorted  array of n elements, write a function to search for the index of a given element (target)&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Search for the array by dividing the array in half repeatedly.&lt;/li&gt;
&lt;li&gt;Initially consider the actual array and pick the element at the middle index&lt;/li&gt;
&lt;li&gt;Keep a lower index i.e. 0 and higher index i.e. length of array&lt;/li&gt;
&lt;li&gt;If it is equal to the target element then return the index&lt;/li&gt;
&lt;li&gt;Else if it is greater than the target element then consider only the left half of array. (lower index = 0, higher = middle - 1)&lt;/li&gt;
&lt;li&gt;Else if it is less than the target element then consider only the right half of array. (lower index = middle + 1, higher = length of array)&lt;/li&gt;
&lt;li&gt;Return -(insertion index + 1) if the target element is not found in the array (If the lower index is greater than or equal to higher index). Some simpler implementations just return -1 if the element is not found. The offset of 1 must be added as the insertion index might be 0 (the searched value might be smaller than all elements in the array). As indexing starts at 0, this must be distinguishable from the case where the target element has the index 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;O(log n) Worst Case  &lt;br&gt;
O(1) Best Case (If middle element of initial array is the target element)&lt;/p&gt;
&lt;h4 id=&#34;space-complexity&#34;&gt;Space Complexity&lt;/h4&gt;
&lt;p&gt;O(1) For iterative approach       &lt;br&gt;
O(1) For recursive approach &lt;em&gt;if tail call optimization is used&lt;/em&gt;, O(log n) due to recursion call stack, otherwise&lt;/p&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr = [1,2,3,4,5,6,7]  

target = 2
Initially the element at middle index is 4 which is greater than 2. Therefore we search the left half of the
array i.e. [1,2,3].
Here we find the middle element equal to target element so we return its index i.e. 1

target = 9          
A simple Binary Search implementation may return -1 as 9 is not present in the array. A more complex one would return the index at which 9 would have to be inserted, which would be `-8` (last position in the array (7) plus one (7+1), negated)`.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Searches/BinarySearch.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Search/Binary%20Search.cpp&#34;&gt;C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/searches/binary_search.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Sharp/blob/master/searches/binary_search.cs&#34;&gt;C-Sharp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C/blob/master/searching/Binary_Search.c&#34;&gt;C&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=5xlIPT1FRcA&#34;&gt;A CS50 video explaining the Binary Search Algorithm&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;animation-explanation&#34;&gt;Animation Explanation&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boardhub.github.io/tute/?wd=binarySearchAlgo2&#34;&gt;Tute Board&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/binarysearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/binarysearch_js_/</guid>
      <description>&lt;p&gt;/* Binary Search: &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_algorithm&#34;&gt;https://en.wikipedia.org/wiki/Binary_search_algorithm&lt;/a&gt;
*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search a sorted array by repeatedly dividing the search interval&lt;/li&gt;
&lt;li&gt;in half. Begin with an interval covering the whole array. If the value of the&lt;/li&gt;
&lt;li&gt;search key is less than the item in the middle of the interval, narrow the interval&lt;/li&gt;
&lt;li&gt;to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the&lt;/li&gt;
&lt;li&gt;value is found or the interval is empty.
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {
const mid = Math.floor(low + (high - low) / 2)&lt;/p&gt;</description>
      <content>&lt;p&gt;/* Binary Search: &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_algorithm&#34;&gt;https://en.wikipedia.org/wiki/Binary_search_algorithm&lt;/a&gt;
*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search a sorted array by repeatedly dividing the search interval&lt;/li&gt;
&lt;li&gt;in half. Begin with an interval covering the whole array. If the value of the&lt;/li&gt;
&lt;li&gt;search key is less than the item in the middle of the interval, narrow the interval&lt;/li&gt;
&lt;li&gt;to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the&lt;/li&gt;
&lt;li&gt;value is found or the interval is empty.
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {
const mid = Math.floor(low + (high - low) / 2)&lt;/p&gt;
&lt;p&gt;if (high &amp;gt;= low) {
if (arr[mid] === x) {
// item found =&amp;gt; return its index
return mid
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (x &amp;lt; arr[mid]) {
  // arr[mid] is an upper bound for x, so if x is in arr =&amp;gt; low &amp;lt;= x &amp;lt; mid
  return binarySearchRecursive(arr, x, low, mid - 1)
} else {
  // arr[mid] is a lower bound for x, so if x is in arr =&amp;gt; mid &amp;lt; x &amp;lt;= high
  return binarySearchRecursive(arr, x, mid + 1, high)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} else {
// if low &amp;gt; high =&amp;gt; we have searched the whole array without finding the item
return -1
}
}
function binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {
while (high &amp;gt;= low) {
const mid = Math.floor(low + (high - low) / 2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (arr[mid] === x) {
  // item found =&amp;gt; return its index
  return mid
}

if (x &amp;lt; arr[mid]) {
  // arr[mid] is an upper bound for x, so if x is in arr =&amp;gt; low &amp;lt;= x &amp;lt; mid
  high = mid - 1
} else {
  // arr[mid] is a lower bound for x, so if x is in arr =&amp;gt; mid &amp;lt; x &amp;lt;= high
  low = mid + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
// if low &amp;gt; high =&amp;gt; we have searched the whole array without finding the item
return -1
}&lt;/p&gt;
&lt;p&gt;export { binarySearchIterative, binarySearchRecursive }&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/exponential-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/exponential-search/</guid>
      <description>&lt;h1 id=&#34;exponential-search&#34;&gt;Exponential Search&lt;/h1&gt;
&lt;h4 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/faridevnz/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md&#34;&gt;Binary Search algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given a sorted array of &lt;em&gt;n&lt;/em&gt; elements, write a function to search for the index of a given element (target)&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Search for the &lt;strong&gt;range&lt;/strong&gt; within which the target is included increasing &lt;em&gt;index&lt;/em&gt; by powers of 2&lt;/li&gt;
&lt;li&gt;If this range exists in array apply the Binary Search algorithm over it&lt;/li&gt;
&lt;li&gt;Else return -1&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;arr = [1, 2, 3, 4, 5, 6, 7, ... 998, 999, 1_000]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target = 998
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;index = 0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;1.&lt;/span&gt; SEARCHING FOR THE RANGE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;index = 1, 2, 4, 8, 16, 32, 64, ..., 512, ..., 1_024
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;after 10 iteration we have the index at 1_024 and outside of the array 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;2.&lt;/span&gt; BINARY SEARCH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Now we can apply the binary search on the subarray from 512 and 1_000.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/em&gt;: we apply the Binary Search from 512 to 1_000 because at &lt;code&gt;i = 2^10 = 1_024&lt;/code&gt; the array is finisced and the target number is less than the latest index of the array ( 1_000 ).&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;exponential-search&#34;&gt;Exponential Search&lt;/h1&gt;
&lt;h4 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/faridevnz/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md&#34;&gt;Binary Search algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given a sorted array of &lt;em&gt;n&lt;/em&gt; elements, write a function to search for the index of a given element (target)&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Search for the &lt;strong&gt;range&lt;/strong&gt; within which the target is included increasing &lt;em&gt;index&lt;/em&gt; by powers of 2&lt;/li&gt;
&lt;li&gt;If this range exists in array apply the Binary Search algorithm over it&lt;/li&gt;
&lt;li&gt;Else return -1&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;arr = [1, 2, 3, 4, 5, 6, 7, ... 998, 999, 1_000]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target = 998
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;index = 0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;1.&lt;/span&gt; SEARCHING FOR THE RANGE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;index = 1, 2, 4, 8, 16, 32, 64, ..., 512, ..., 1_024
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;after 10 iteration we have the index at 1_024 and outside of the array 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;2.&lt;/span&gt; BINARY SEARCH
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Now we can apply the binary search on the subarray from 512 and 1_000.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/em&gt;: we apply the Binary Search from 512 to 1_000 because at &lt;code&gt;i = 2^10 = 1_024&lt;/code&gt; the array is finisced and the target number is less than the latest index of the array ( 1_000 ).&lt;/p&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;worst case:&lt;/strong&gt; &lt;code&gt;O(log *i*)&lt;/code&gt; where &lt;code&gt;*i* = index&lt;/code&gt; (position) of the target&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;best case:&lt;/strong&gt; &lt;code&gt;O(*1*)&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;complexity-explanation&#34;&gt;Complexity Explanation&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The complexity of the first part of the algorithm is &lt;strong&gt;O( log &lt;em&gt;i&lt;/em&gt; )&lt;/strong&gt; because if &lt;em&gt;i&lt;/em&gt; is the position of the target in the array, after doubling the search &lt;em&gt;index&lt;/em&gt; &lt;code&gt;⌈log(i)⌉&lt;/code&gt; times, the algorithm will be at a search index that is greater than or equal to &lt;em&gt;i&lt;/em&gt;. We can write &lt;code&gt;2^⌈log(i)⌉ &amp;gt;= i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The complexity of the second part of the algorithm also is &lt;strong&gt;O ( log &lt;em&gt;i&lt;/em&gt; )&lt;/strong&gt; because that is a simple Binary Search. The Binary Search complexity ( as explained &lt;a href=&#34;https://github.com/faridevnz/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md&#34;&gt;here&lt;/a&gt; ) is O( &lt;em&gt;n&lt;/em&gt; ) where &lt;em&gt;n&lt;/em&gt; is the length of the array. In the Exponential Search, the length of the array on which the algorithm is applied is &lt;code&gt;2^i - 2^(i-1)&lt;/code&gt;, put into words it means &amp;lsquo;( the length of the array from start to &lt;em&gt;i&lt;/em&gt; ) - ( the part of array skipped until the previous iteration )&amp;rsquo;. Is simple verify that &lt;code&gt;2^i - 2^(i-1) = 2^(i-1) &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After this detailed explanation we can say that the the complexity of the Exponential Search is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mathematica&#34; data-lang=&#34;mathematica&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;O(log i) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; O(log i) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;O(log i) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; O(log i)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;binary-search-vs-exponential-search&#34;&gt;Binary Search vs Exponential Search&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at this comparison with a less theoretical example. Imagine we have an array with&lt;code&gt;1_000_000&lt;/code&gt; elements and we want to search an element that is in the &lt;code&gt;4th&lt;/code&gt; position. It&amp;rsquo;s easy to see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Binary Search start from the middle of the array and arrive to the 4th position after many iterations&lt;/li&gt;
&lt;li&gt;The Exponential Search arrive at the 4th index after only 2 iterations&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/exponential_search.cpp&#34;&gt;C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Javascript/blob/master/Search/ExponentialSearch.js&#34;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/exponentialsearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/exponentialsearch_js_/</guid>
      <description>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exponential Search&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The algorithm consists of two stages. The first stage determines a&lt;/li&gt;
&lt;li&gt;range in which the search key would reside if it were in the list.&lt;/li&gt;
&lt;li&gt;In the second stage, a binary search is performed on this range.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;function binarySearch (arr, value, floor, ceiling) {
// Middle index
const mid = Math.floor((floor + ceiling) / 2)&lt;/p&gt;
&lt;p&gt;// If value is at the mid position return this position
if (arr[mid] === value) {
return mid
}&lt;/p&gt;</description>
      <content>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exponential Search&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The algorithm consists of two stages. The first stage determines a&lt;/li&gt;
&lt;li&gt;range in which the search key would reside if it were in the list.&lt;/li&gt;
&lt;li&gt;In the second stage, a binary search is performed on this range.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;function binarySearch (arr, value, floor, ceiling) {
// Middle index
const mid = Math.floor((floor + ceiling) / 2)&lt;/p&gt;
&lt;p&gt;// If value is at the mid position return this position
if (arr[mid] === value) {
return mid
}&lt;/p&gt;
&lt;p&gt;if (floor &amp;gt; ceiling) return -1&lt;/p&gt;
&lt;p&gt;// If the middle element is great than the value
// search the left part of the array
if (arr[mid] &amp;gt; value) {
return binarySearch(arr, value, floor, mid - 1)
// If the middle element is lower than the value
// search the right part of the array
} else {
return binarySearch(arr, value, mid + 1, ceiling)
}
}&lt;/p&gt;
&lt;p&gt;function exponentialSearch (arr, length, value) {
// If value is the first element of the array return this position
if (arr[0] === value) {
return 0
}&lt;/p&gt;
&lt;p&gt;// Find range for binary search
let i = 1
while (i &amp;lt; length &amp;amp;&amp;amp; arr[i] &amp;lt;= value) {
i = i * 2
}&lt;/p&gt;
&lt;p&gt;// Call binary search for the range found above
return binarySearch(arr, value, i / 2, Math.min(i, length))
}&lt;/p&gt;
&lt;p&gt;export { binarySearch, exponentialSearch }&lt;/p&gt;
&lt;p&gt;// const arr = [2, 3, 4, 10, 40, 65, 78, 100]
// const value = 78
// const result = exponentialSearch(arr, arr.length, value)&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/fibonaccisearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/fibonaccisearch_js_/</guid>
      <description>&lt;p&gt;/****************************************************************************&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fibonacci Search JavaScript Implementation&lt;/li&gt;
&lt;li&gt;Author   Alhassan Atama Isiaka&lt;/li&gt;
&lt;li&gt;Version v1.0.0&lt;/li&gt;
&lt;li&gt;Copyright 2020&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/komputarist&#34;&gt;https://github.com/komputarist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;This implementation is based on Generalizing the Fibonacci search we&lt;/li&gt;
&lt;li&gt;define the Fibonacci search of degree K. Like the Fibonacci search,&lt;/li&gt;
&lt;li&gt;which it reduces to for K = 2, the Fibonacci search of degree K&lt;/li&gt;
&lt;li&gt;involves only addition and subtraction.&lt;/li&gt;
&lt;li&gt;Capocelli R.M. (1991) A Generalization of the Fibonacci Search. In:&lt;/li&gt;
&lt;li&gt;Bergum G.E., Philippou A.N., Horadam A.F. (eds) Applications of Fibonacci&lt;/li&gt;
&lt;li&gt;Numbers. Springer, Dordrecht. &lt;a href=&#34;https://doi.org/10.1007/978-94-011-3586-3_9&#34;&gt;https://doi.org/10.1007/978-94-011-3586-3_9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;This snippet is free. Feel free to improve on it&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;We define a function fibonacciSearch() that takes an array of numbers,&lt;/li&gt;
&lt;li&gt;the item (number) to be searched for and the length of the items in the array
****************************************************************************/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export const fibonacciSearch = (arr, x, n) =&amp;gt; {
let fib2 = 0 // (K-2)&amp;rsquo;th Fibonacci Number
let fib1 = 1 // (K-1)&amp;rsquo;th Fibonacci Number.
let fibK = fib2 + fib1 // Kth Fibonacci&lt;/p&gt;</description>
      <content>&lt;p&gt;/****************************************************************************&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fibonacci Search JavaScript Implementation&lt;/li&gt;
&lt;li&gt;Author   Alhassan Atama Isiaka&lt;/li&gt;
&lt;li&gt;Version v1.0.0&lt;/li&gt;
&lt;li&gt;Copyright 2020&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/komputarist&#34;&gt;https://github.com/komputarist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;This implementation is based on Generalizing the Fibonacci search we&lt;/li&gt;
&lt;li&gt;define the Fibonacci search of degree K. Like the Fibonacci search,&lt;/li&gt;
&lt;li&gt;which it reduces to for K = 2, the Fibonacci search of degree K&lt;/li&gt;
&lt;li&gt;involves only addition and subtraction.&lt;/li&gt;
&lt;li&gt;Capocelli R.M. (1991) A Generalization of the Fibonacci Search. In:&lt;/li&gt;
&lt;li&gt;Bergum G.E., Philippou A.N., Horadam A.F. (eds) Applications of Fibonacci&lt;/li&gt;
&lt;li&gt;Numbers. Springer, Dordrecht. &lt;a href=&#34;https://doi.org/10.1007/978-94-011-3586-3_9&#34;&gt;https://doi.org/10.1007/978-94-011-3586-3_9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;This snippet is free. Feel free to improve on it&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;We define a function fibonacciSearch() that takes an array of numbers,&lt;/li&gt;
&lt;li&gt;the item (number) to be searched for and the length of the items in the array
****************************************************************************/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export const fibonacciSearch = (arr, x, n) =&amp;gt; {
let fib2 = 0 // (K-2)&amp;rsquo;th Fibonacci Number
let fib1 = 1 // (K-1)&amp;rsquo;th Fibonacci Number.
let fibK = fib2 + fib1 // Kth Fibonacci&lt;/p&gt;
&lt;p&gt;/* We want to store the smallest fibonacci number smaller such that
number is greater than or equal to n, we use fibK for this */
while (fibK &amp;lt; n) {
fib2 = fib1
fib1 = fibK
fibK = fib2 + fib1
}
//  This marks the eliminated range from front
let offset = -1&lt;/p&gt;
&lt;p&gt;/* while there are elements to be checked. We compare arr[fib2] with x.
When fibM becomes 1, fib2 becomes 0 */&lt;/p&gt;
&lt;p&gt;while (fibK &amp;gt; 1) {
// Check if fibK is a valid location
const i = Math.min(offset + fib2, n - 1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*  If x is greater than the value at
  index fib2, Partition the subarray array
  from offset to i */
if (arr[i] &amp;lt; x) {
  fibK = fib1
  fib1 = fib2
  fib2 = fibK - fib1
  offset = i
  /* If x is greater than the value at
        index fib2, cut the subarray array
        from offset to i */
} else if (arr[i] &amp;gt; x) {
  fibK = fib2
  fib1 = fib1 - fib2
  fib2 = fibK - fib1
} else {
//  return index for found element
  return i
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;//    comparing the last element with x */
if (fib1 &amp;amp;&amp;amp; arr[offset + 1] === x) {
return offset + 1
}
//    element not found. return -1
return -1
}&lt;/p&gt;
&lt;p&gt;// Example
// const myArray = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
// const n = myArray.length
// const x = 90
// const fibFinder = fibonacciSearch(myArray, x, n)&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/floyd-cycle-detection-algorithm-to-find-duplicate-number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/floyd-cycle-detection-algorithm-to-find-duplicate-number/</guid>
      <description>&lt;h1 id=&#34;floyd-cycle-detection-algorithm-to-find-duplicate-number-in-an-array&#34;&gt;Floyd Cycle Detection Algorithm to find duplicate number in an array&lt;/h1&gt;
&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an array of integers containing &lt;code&gt;n + 1&lt;/code&gt; integers, where each integer is in the range &lt;code&gt;[1, n]&lt;/code&gt; inclusive. If there is only one duplicate number in the input array, this algorithm returns the duplicate number without modifying the original array, otherwise, it returns -1.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the function &lt;code&gt;f(x) = arr[x]&lt;/code&gt; to construct the sequence:
&lt;code&gt;arr[0]&lt;/code&gt;, &lt;code&gt;arr[arr[0]]&lt;/code&gt;, &lt;code&gt;arr[arr[arr[0]]]&lt;/code&gt;, &lt;code&gt;arr[arr[arr[arr[0]]]]&lt;/code&gt;, etc&amp;hellip;.&lt;/li&gt;
&lt;li&gt;Each new element in the sequence is an element in &lt;code&gt;arr[]&lt;/code&gt; at the index of the previous element.&lt;/li&gt;
&lt;li&gt;Starting from &lt;code&gt;x = arr[0]&lt;/code&gt;, it will produce a linked list with a cycle.&lt;/li&gt;
&lt;li&gt;The cycle appears because &lt;code&gt;arr[]&lt;/code&gt; contains duplicate elements(at least one). The duplicate value is an entrance to the cycle.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h2&gt;
&lt;p&gt;O(n)&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;floyd-cycle-detection-algorithm-to-find-duplicate-number-in-an-array&#34;&gt;Floyd Cycle Detection Algorithm to find duplicate number in an array&lt;/h1&gt;
&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an array of integers containing &lt;code&gt;n + 1&lt;/code&gt; integers, where each integer is in the range &lt;code&gt;[1, n]&lt;/code&gt; inclusive. If there is only one duplicate number in the input array, this algorithm returns the duplicate number without modifying the original array, otherwise, it returns -1.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the function &lt;code&gt;f(x) = arr[x]&lt;/code&gt; to construct the sequence:
&lt;code&gt;arr[0]&lt;/code&gt;, &lt;code&gt;arr[arr[0]]&lt;/code&gt;, &lt;code&gt;arr[arr[arr[0]]]&lt;/code&gt;, &lt;code&gt;arr[arr[arr[arr[0]]]]&lt;/code&gt;, etc&amp;hellip;.&lt;/li&gt;
&lt;li&gt;Each new element in the sequence is an element in &lt;code&gt;arr[]&lt;/code&gt; at the index of the previous element.&lt;/li&gt;
&lt;li&gt;Starting from &lt;code&gt;x = arr[0]&lt;/code&gt;, it will produce a linked list with a cycle.&lt;/li&gt;
&lt;li&gt;The cycle appears because &lt;code&gt;arr[]&lt;/code&gt; contains duplicate elements(at least one). The duplicate value is an entrance to the cycle.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h2&gt;
&lt;p&gt;O(n)&lt;/p&gt;
&lt;h2 id=&#34;space-complexity&#34;&gt;Space Complexity&lt;/h2&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr = [3, 4, 8, 5, 9, 1, 2, 6, 7, 4]  

return value = 4
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/floyd_cycle_detection_algo.cpp&#34;&gt;C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C/blob/master/searching/floyd_cycle_detection_algorithm.c&#34;&gt;C&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=B6smdk7pZ14&#34;&gt;YouTube video explaining the Floyd Cycle Detection algorithm&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/interpolationsearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/interpolationsearch_js_/</guid>
      <description>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interpolation Search
*&lt;/li&gt;
&lt;li&gt;Time Complexity:&lt;/li&gt;
&lt;li&gt;-Best case: O(1)&lt;/li&gt;
&lt;li&gt;-Worst case: O(n)&lt;/li&gt;
&lt;li&gt;-O((log(log(n))) If the data are uniformly distributed
*
*
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export function interpolationSearch (arr, key) {
const length = arr.length - 1
let low = 0
let high = length
let position = -1
let delta = -1&lt;/p&gt;
&lt;p&gt;// Because the array is sorted the key must be between low and high
while (low &amp;lt;= high &amp;amp;&amp;amp; key &amp;gt;= arr[low] &amp;amp;&amp;amp; key &amp;lt;= arr[high]) {
delta = (key - arr[low]) / (arr[high] - arr[low])
position = low + Math.floor((high - low) * delta)&lt;/p&gt;</description>
      <content>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interpolation Search
*&lt;/li&gt;
&lt;li&gt;Time Complexity:&lt;/li&gt;
&lt;li&gt;-Best case: O(1)&lt;/li&gt;
&lt;li&gt;-Worst case: O(n)&lt;/li&gt;
&lt;li&gt;-O((log(log(n))) If the data are uniformly distributed
*
*
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export function interpolationSearch (arr, key) {
const length = arr.length - 1
let low = 0
let high = length
let position = -1
let delta = -1&lt;/p&gt;
&lt;p&gt;// Because the array is sorted the key must be between low and high
while (low &amp;lt;= high &amp;amp;&amp;amp; key &amp;gt;= arr[low] &amp;amp;&amp;amp; key &amp;lt;= arr[high]) {
delta = (key - arr[low]) / (arr[high] - arr[low])
position = low + Math.floor((high - low) * delta)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Target found return its position
if (arr[position] === key) {
  return position
}

// If the key is larger then it is in the upper part of the array
if (arr[position] &amp;lt; key) {
  low = position + 1
  // If the key is smaller then it is in the lower part of the array
} else {
  high = position - 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;return -1
}&lt;/p&gt;
&lt;p&gt;// const arr = [2, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 34, 39]&lt;/p&gt;
&lt;p&gt;// interpolationSearch(arr, 2)
// interpolationSearch(arr, 12)
// interpolationSearch(arr, 1000)
// interpolationSearch(arr, 39)&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/jumpsearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/jumpsearch_js_/</guid>
      <description>&lt;p&gt;/* The Jump Search algorithm allows to combine a linear search with a speed optimization.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This means that instead of going 1 by 1, we will increase the step of √n and increase that&lt;/li&gt;
&lt;li&gt;step of √n which make the step getting bigger and bigger.&lt;/li&gt;
&lt;li&gt;The asymptotic analysis of Jump Search is o(√n). Like the binary search, it needs to be sorted.&lt;/li&gt;
&lt;li&gt;The advantage against binary search is that Jump Search traversed back only once.
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;const jumpSearch = (arr, value) =&amp;gt; {
const length = arr.length
let step = Math.floor(Math.sqrt(length))
let lowerBound = 0
while (arr[Math.min(step, length) - 1] &amp;lt; value) {
lowerBound = step
step += step
if (lowerBound &amp;gt;= length) {
return -1
}
}&lt;/p&gt;</description>
      <content>&lt;p&gt;/* The Jump Search algorithm allows to combine a linear search with a speed optimization.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This means that instead of going 1 by 1, we will increase the step of √n and increase that&lt;/li&gt;
&lt;li&gt;step of √n which make the step getting bigger and bigger.&lt;/li&gt;
&lt;li&gt;The asymptotic analysis of Jump Search is o(√n). Like the binary search, it needs to be sorted.&lt;/li&gt;
&lt;li&gt;The advantage against binary search is that Jump Search traversed back only once.
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;const jumpSearch = (arr, value) =&amp;gt; {
const length = arr.length
let step = Math.floor(Math.sqrt(length))
let lowerBound = 0
while (arr[Math.min(step, length) - 1] &amp;lt; value) {
lowerBound = step
step += step
if (lowerBound &amp;gt;= length) {
return -1
}
}&lt;/p&gt;
&lt;p&gt;const upperBound = Math.min(step, length)
while (arr[lowerBound] &amp;lt; value) {
lowerBound++
if (lowerBound === upperBound) {
return -1
}
}
if (arr[lowerBound] === value) {
return lowerBound
}
return -1
}&lt;/p&gt;
&lt;p&gt;export { jumpSearch }&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/linear-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/linear-search/</guid>
      <description>&lt;h1 id=&#34;linear-search&#34;&gt;Linear Search&lt;/h1&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given an array of n elements, write a function to search for the index of a given element (target)&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Start iterating with the first element in the array.&lt;/li&gt;
&lt;li&gt;Compare it with the target element&lt;/li&gt;
&lt;li&gt;If it is equal to the target element then return the index&lt;/li&gt;
&lt;li&gt;Else continue iterating&lt;/li&gt;
&lt;li&gt;Return -1 if target element is not found in the array&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;O(n) Worse Case  &lt;br&gt;
O(1) Best Case (If first element of array is the target element)&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;linear-search&#34;&gt;Linear Search&lt;/h1&gt;
&lt;h4 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h4&gt;
&lt;p&gt;Given an array of n elements, write a function to search for the index of a given element (target)&lt;/p&gt;
&lt;h4 id=&#34;approach&#34;&gt;Approach&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Start iterating with the first element in the array.&lt;/li&gt;
&lt;li&gt;Compare it with the target element&lt;/li&gt;
&lt;li&gt;If it is equal to the target element then return the index&lt;/li&gt;
&lt;li&gt;Else continue iterating&lt;/li&gt;
&lt;li&gt;Return -1 if target element is not found in the array&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h4&gt;
&lt;p&gt;O(n) Worse Case  &lt;br&gt;
O(1) Best Case (If first element of array is the target element)&lt;/p&gt;
&lt;h4 id=&#34;space-complexity&#34;&gt;Space Complexity&lt;/h4&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arr = [1, 3, 9, 5, 0, 2]  

target = 5
Linear Search should return index 3 as 5 is on index 3     

target = 6           
Linear Search should return -1 as 6 is not present in the array
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;code-implementation-links&#34;&gt;Code Implementation Links&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Java/blob/master/Searches/LinearSearch.java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Search/Linear%20Search.cpp&#34;&gt;C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/Python/blob/master/searches/linear_search.py&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;video-explanation&#34;&gt;Video Explanation&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=CX2CYIJLwfg&#34;&gt;A CS50 video explaining the Linear Search Algorithm&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;animation-explanation&#34;&gt;Animation Explanation&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boardhub.github.io/tute/?wd=linearSearchAlgo&#34;&gt;Tute Board&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/linearsearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/linearsearch_js_/</guid>
      <description>&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linear search or sequential search is a method for finding a target&lt;/li&gt;
&lt;li&gt;value within a list. It sequentially checks each element of the list&lt;/li&gt;
&lt;li&gt;for the target value until a match is found or until all the elements&lt;/li&gt;
&lt;li&gt;have been searched.
*/
function SearchArray (searchNum, ar, output = v =&amp;gt; console.log(v)) {
const position = Search(ar, searchNum)
if (position !== -1) {
output(&amp;lsquo;The element was found at &amp;rsquo; + (position + 1))
} else {
output(&amp;lsquo;The element not found&amp;rsquo;)
}
}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// Search “theArray” for the specified “key” value
function Search (theArray, key) {
for (let n = 0; n &amp;lt; theArray.length; n++) {
if (theArray[n] === key) { return n }
}
return -1
}&lt;/p&gt;</description>
      <content>&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linear search or sequential search is a method for finding a target&lt;/li&gt;
&lt;li&gt;value within a list. It sequentially checks each element of the list&lt;/li&gt;
&lt;li&gt;for the target value until a match is found or until all the elements&lt;/li&gt;
&lt;li&gt;have been searched.
*/
function SearchArray (searchNum, ar, output = v =&amp;gt; console.log(v)) {
const position = Search(ar, searchNum)
if (position !== -1) {
output(&amp;lsquo;The element was found at &amp;rsquo; + (position + 1))
} else {
output(&amp;lsquo;The element not found&amp;rsquo;)
}
}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// Search “theArray” for the specified “key” value
function Search (theArray, key) {
for (let n = 0; n &amp;lt; theArray.length; n++) {
if (theArray[n] === key) { return n }
}
return -1
}&lt;/p&gt;
&lt;p&gt;export { SearchArray, Search }&lt;/p&gt;
&lt;p&gt;// const ar = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// SearchArray(3, ar)
// SearchArray(4, ar)
// SearchArray(11, ar)&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/quickselectsearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/quickselectsearch_js_/</guid>
      <description>&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Places the &lt;code&gt;k&lt;/code&gt; smallest elements in &lt;code&gt;array&lt;/code&gt; in the first &lt;code&gt;k&lt;/code&gt; indices: &lt;code&gt;[0..k-1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Modifies the passed in array &lt;em&gt;in place&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Returns a slice of the wanted elements for convenience&lt;/li&gt;
&lt;li&gt;Efficient mainly because it never performs a full sort.
*&lt;/li&gt;
&lt;li&gt;The only guarantees are that:
*&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;k&lt;/code&gt;th element is in its final sort index (if the array were to be sorted)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;All elements before index &lt;code&gt;k&lt;/code&gt; are smaller than the &lt;code&gt;k&lt;/code&gt;th element
*&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Quickselect&#34;&gt;Reference&lt;/a&gt;
*/
export function quickSelectSearch (array, k) {
if (!array || array.length &amp;lt;= k) {
throw new Error(&amp;lsquo;Invalid arguments&amp;rsquo;)
}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;let from = 0
let to = array.length - 1
while (from &amp;lt; to) {
let left = from
let right = to
const pivot = array[Math.ceil((left + right) * 0.5)]&lt;/p&gt;</description>
      <content>&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Places the &lt;code&gt;k&lt;/code&gt; smallest elements in &lt;code&gt;array&lt;/code&gt; in the first &lt;code&gt;k&lt;/code&gt; indices: &lt;code&gt;[0..k-1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Modifies the passed in array &lt;em&gt;in place&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Returns a slice of the wanted elements for convenience&lt;/li&gt;
&lt;li&gt;Efficient mainly because it never performs a full sort.
*&lt;/li&gt;
&lt;li&gt;The only guarantees are that:
*&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;k&lt;/code&gt;th element is in its final sort index (if the array were to be sorted)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;All elements before index &lt;code&gt;k&lt;/code&gt; are smaller than the &lt;code&gt;k&lt;/code&gt;th element
*&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Quickselect&#34;&gt;Reference&lt;/a&gt;
*/
export function quickSelectSearch (array, k) {
if (!array || array.length &amp;lt;= k) {
throw new Error(&amp;lsquo;Invalid arguments&amp;rsquo;)
}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;let from = 0
let to = array.length - 1
while (from &amp;lt; to) {
let left = from
let right = to
const pivot = array[Math.ceil((left + right) * 0.5)]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (left &amp;lt; right) {
  if (array[left] &amp;gt;= pivot) {
    const tmp = array[left]
    array[left] = array[right]
    array[right] = tmp
    --right
  } else {
    ++left
  }
}

if (array[left] &amp;gt; pivot) {
  --left
}

if (k &amp;lt;= left) {
  to = left
} else {
  from = left + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
return array
}&lt;/p&gt;
&lt;p&gt;/* &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- Test &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- */&lt;/p&gt;
&lt;p&gt;// const arr = [1121111, 21, 333, 41, 5, 66, 7777, 28, 19, 11110]
// quickSelectSearch(arr, 5) // [ 19, 21, 28, 41, 5, 66, 333, 11110, 1121111, 7777 ]
// quickSelectSearch(arr, 2) // [ 19, 5, 21, 41, 28, 333, 11110, 1121111, 7777, 66 ]
// quickSelectSearch(arr, 7) // [ 19, 5, 21, 41, 28, 66, 333, 7777, 11110, 1121111 ]&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/slidingwindow_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/slidingwindow_js_/</guid>
      <description>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sliding Window:&lt;/li&gt;
&lt;li&gt;This pattern involve creating a window which can either be&lt;/li&gt;
&lt;li&gt;an array or numbers from one position to another.
*&lt;/li&gt;
&lt;li&gt;Depending on a certain condition, the window either increases&lt;/li&gt;
&lt;li&gt;or closes (and a new window is created).
*&lt;/li&gt;
&lt;li&gt;Very useful for keeping track of a subset of data in an&lt;/li&gt;
&lt;li&gt;array/string etc.
*&lt;/li&gt;
&lt;li&gt;Time Complexity: Best - O(n);
*&lt;/li&gt;
&lt;li&gt;Examples:&lt;/li&gt;
&lt;li&gt;maxSubarraySum([1,2,5,2,8,1,5],2) // returns 10&lt;/li&gt;
&lt;li&gt;maxSubarraySum([1,2,5,2,8,1,5],15) // returns null&lt;/li&gt;
&lt;li&gt;maxSubarraySum([5,2,6,9],3) // returns 17&lt;/li&gt;
&lt;li&gt;@param {[Int]} arr - An array of integers on which we will perform the test.&lt;/li&gt;
&lt;li&gt;@param {Int} num - An integer that displays the size of the window you want to check.&lt;/li&gt;
&lt;li&gt;@returns {Int / Null} - Returns a total of N consecutive numbers or null
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function slidingWindow (arr, num) {
// Edge Case:
// If the length of the array shorter than the window size (num) return null.
if (arr.length &amp;lt; num) return null
// The highest amount of consecutive numbers
let maxSum = 0
// Temp amount of consecutive numbers - For comparative purposes
let tempSum = 0
// loop over the array {num} times and save their total amount in {maxSum}
for (let i = 0; i &amp;lt; num; i++) {
maxSum += arr[i]
}
// initialize {tempSum} to {maxSum}.
tempSum = maxSum
// loop over the array n times
for (let i = num; i &amp;lt; arr.length; i++) {
// Add the next num in the array and remove the first one
tempSum = tempSum - arr[i - num] + arr[i]
// save the largest number between {maxNum} and {tempNum} in maxSum.
maxSum = Math.max(maxSum, tempSum)
}
return maxSum
}&lt;/p&gt;</description>
      <content>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sliding Window:&lt;/li&gt;
&lt;li&gt;This pattern involve creating a window which can either be&lt;/li&gt;
&lt;li&gt;an array or numbers from one position to another.
*&lt;/li&gt;
&lt;li&gt;Depending on a certain condition, the window either increases&lt;/li&gt;
&lt;li&gt;or closes (and a new window is created).
*&lt;/li&gt;
&lt;li&gt;Very useful for keeping track of a subset of data in an&lt;/li&gt;
&lt;li&gt;array/string etc.
*&lt;/li&gt;
&lt;li&gt;Time Complexity: Best - O(n);
*&lt;/li&gt;
&lt;li&gt;Examples:&lt;/li&gt;
&lt;li&gt;maxSubarraySum([1,2,5,2,8,1,5],2) // returns 10&lt;/li&gt;
&lt;li&gt;maxSubarraySum([1,2,5,2,8,1,5],15) // returns null&lt;/li&gt;
&lt;li&gt;maxSubarraySum([5,2,6,9],3) // returns 17&lt;/li&gt;
&lt;li&gt;@param {[Int]} arr - An array of integers on which we will perform the test.&lt;/li&gt;
&lt;li&gt;@param {Int} num - An integer that displays the size of the window you want to check.&lt;/li&gt;
&lt;li&gt;@returns {Int / Null} - Returns a total of N consecutive numbers or null
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function slidingWindow (arr, num) {
// Edge Case:
// If the length of the array shorter than the window size (num) return null.
if (arr.length &amp;lt; num) return null
// The highest amount of consecutive numbers
let maxSum = 0
// Temp amount of consecutive numbers - For comparative purposes
let tempSum = 0
// loop over the array {num} times and save their total amount in {maxSum}
for (let i = 0; i &amp;lt; num; i++) {
maxSum += arr[i]
}
// initialize {tempSum} to {maxSum}.
tempSum = maxSum
// loop over the array n times
for (let i = num; i &amp;lt; arr.length; i++) {
// Add the next num in the array and remove the first one
tempSum = tempSum - arr[i - num] + arr[i]
// save the largest number between {maxNum} and {tempNum} in maxSum.
maxSum = Math.max(maxSum, tempSum)
}
return maxSum
}&lt;/p&gt;
&lt;p&gt;export { slidingWindow }&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/stringsearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/stringsearch_js_/</guid>
      <description>&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String Search
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function makeTable (str) {
// create a table of size equal to the length of &lt;code&gt;str&lt;/code&gt;
// table[i] will store the prefix of the longest prefix of the substring str[0..i]
const table = new Array(str.length)
let maxPrefix = 0
// the longest prefix of the substring str[0] has length
table[0] = 0&lt;/p&gt;
&lt;p&gt;// for the substrings the following substrings, we have two cases
for (let i = 1; i &amp;lt; str.length; i++) {
// case 1. the current character doesn&amp;rsquo;t match the last character of the longest prefix
while (maxPrefix &amp;gt; 0 &amp;amp;&amp;amp; str.charAt(i) !== str.charAt(maxPrefix)) {
// if that is the case, we have to backtrack, and try find a character  that will be equal to the current character
// if we reach 0, then we couldn&amp;rsquo;t find a character
maxPrefix = table[maxPrefix - 1]
}
// case 2. The last character of the longest prefix matches the current character in &lt;code&gt;str&lt;/code&gt;
if (str.charAt(maxPrefix) === str.charAt(i)) {
// if that is the case, we know that the longest prefix at position i has one more character.
// for example consider &lt;code&gt;.&lt;/code&gt; be any character not contained in the set [a.c]
// str = abc&amp;hellip;.abc
// consider &lt;code&gt;i&lt;/code&gt; to be the last character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;
// maxPrefix = will be 2 (the first &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;)
// maxPrefix now will be 3
maxPrefix++
// so the max prefix for table[9] is 3
}
table[i] = maxPrefix
}
return table
}&lt;/p&gt;</description>
      <content>&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String Search
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function makeTable (str) {
// create a table of size equal to the length of &lt;code&gt;str&lt;/code&gt;
// table[i] will store the prefix of the longest prefix of the substring str[0..i]
const table = new Array(str.length)
let maxPrefix = 0
// the longest prefix of the substring str[0] has length
table[0] = 0&lt;/p&gt;
&lt;p&gt;// for the substrings the following substrings, we have two cases
for (let i = 1; i &amp;lt; str.length; i++) {
// case 1. the current character doesn&amp;rsquo;t match the last character of the longest prefix
while (maxPrefix &amp;gt; 0 &amp;amp;&amp;amp; str.charAt(i) !== str.charAt(maxPrefix)) {
// if that is the case, we have to backtrack, and try find a character  that will be equal to the current character
// if we reach 0, then we couldn&amp;rsquo;t find a character
maxPrefix = table[maxPrefix - 1]
}
// case 2. The last character of the longest prefix matches the current character in &lt;code&gt;str&lt;/code&gt;
if (str.charAt(maxPrefix) === str.charAt(i)) {
// if that is the case, we know that the longest prefix at position i has one more character.
// for example consider &lt;code&gt;.&lt;/code&gt; be any character not contained in the set [a.c]
// str = abc&amp;hellip;.abc
// consider &lt;code&gt;i&lt;/code&gt; to be the last character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;
// maxPrefix = will be 2 (the first &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;)
// maxPrefix now will be 3
maxPrefix++
// so the max prefix for table[9] is 3
}
table[i] = maxPrefix
}
return table
}&lt;/p&gt;
&lt;p&gt;// Find all the words that matches in a given string &lt;code&gt;str&lt;/code&gt;
export function stringSearch (str, word) {
// find the prefix table in O(n)
const prefixes = makeTable(word)
const matches = []&lt;/p&gt;
&lt;p&gt;// &lt;code&gt;j&lt;/code&gt; is the index in &lt;code&gt;P&lt;/code&gt;
let j = 0
// &lt;code&gt;i&lt;/code&gt; is the index in &lt;code&gt;S&lt;/code&gt;
let i = 0
while (i &amp;lt; str.length) {
// Case 1.  S[i] == P[j] so we move to the next index in &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;
if (str.charAt(i) === word.charAt(j)) {
i++
j++
}
// Case 2.  &lt;code&gt;j&lt;/code&gt; is equal to the length of &lt;code&gt;P&lt;/code&gt;
// that means that we reached the end of &lt;code&gt;P&lt;/code&gt; and thus we found a match
// Next we have to update &lt;code&gt;j&lt;/code&gt; because we want to save some time
// instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.
// j-1 means the last character of &lt;code&gt;P&lt;/code&gt; because j is actually &lt;code&gt;P.length&lt;/code&gt;
// e.g.
// S =  a b a b d e
// P = &lt;code&gt;a b&lt;/code&gt;a b
// we will jump to &lt;code&gt;a b&lt;/code&gt; and we will compare d and a in the next iteration
// a b a b &lt;code&gt;d&lt;/code&gt; e
//     a b &lt;code&gt;a&lt;/code&gt; b
if (j === word.length) {
matches.push(i - j)
j = prefixes[j - 1]
// Case 3.
// S[i] != P[j] There&amp;rsquo;s a mismatch!
} else if (str.charAt(i) !== word.charAt(j)) {
// if we  found at least a character in common, do the same thing as in case 2
if (j !== 0) {
j = prefixes[j - 1]
} else {
// else j = 0, and we can move to the next character S[i+1]
i++
}
}
}&lt;/p&gt;
&lt;p&gt;return matches
}&lt;/p&gt;
&lt;p&gt;// stringSearch(&amp;lsquo;Hello search the position of me&amp;rsquo;, &amp;lsquo;pos&amp;rsquo;)&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/ternarysearch_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/ternarysearch_js_/</guid>
      <description>&lt;p&gt;/* Ternary search is similar to binary search but it divide the sorted array&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;into three parts and determine which part the key lies in. The array will&lt;/li&gt;
&lt;li&gt;be divided into three intervals by using two middle points, mid1 and mid2.&lt;/li&gt;
&lt;li&gt;The value of the key will first compared with the two mid points, the value&lt;/li&gt;
&lt;li&gt;will be returned if there is a match. Then, if the value of the key is less&lt;/li&gt;
&lt;li&gt;than mid1, narrow the interval to the first part. Else, if the value of the&lt;/li&gt;
&lt;li&gt;key is greater than mid2, narrow the interval to the third part. Otherwise,&lt;/li&gt;
&lt;li&gt;narrow the interval to the middle part. Repeat the steps until the value is&lt;/li&gt;
&lt;li&gt;found or the interval is empty(value not found after checking all elements).
*&lt;/li&gt;
&lt;li&gt;Reference: &lt;a href=&#34;https://www.geeksforgeeks.org/ternary-search/&#34;&gt;https://www.geeksforgeeks.org/ternary-search/&lt;/a&gt;
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {
if (high &amp;gt;= low) {
// find the mid1 and mid2
const mid1 = Math.floor(low + (high - low) / 3)
const mid2 = Math.floor(high - (high - low) / 3)&lt;/p&gt;</description>
      <content>&lt;p&gt;/* Ternary search is similar to binary search but it divide the sorted array&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;into three parts and determine which part the key lies in. The array will&lt;/li&gt;
&lt;li&gt;be divided into three intervals by using two middle points, mid1 and mid2.&lt;/li&gt;
&lt;li&gt;The value of the key will first compared with the two mid points, the value&lt;/li&gt;
&lt;li&gt;will be returned if there is a match. Then, if the value of the key is less&lt;/li&gt;
&lt;li&gt;than mid1, narrow the interval to the first part. Else, if the value of the&lt;/li&gt;
&lt;li&gt;key is greater than mid2, narrow the interval to the third part. Otherwise,&lt;/li&gt;
&lt;li&gt;narrow the interval to the middle part. Repeat the steps until the value is&lt;/li&gt;
&lt;li&gt;found or the interval is empty(value not found after checking all elements).
*&lt;/li&gt;
&lt;li&gt;Reference: &lt;a href=&#34;https://www.geeksforgeeks.org/ternary-search/&#34;&gt;https://www.geeksforgeeks.org/ternary-search/&lt;/a&gt;
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;function ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {
if (high &amp;gt;= low) {
// find the mid1 and mid2
const mid1 = Math.floor(low + (high - low) / 3)
const mid2 = Math.floor(high - (high - low) / 3)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// check if key is found at any mid
if (arr[mid1] === key) {
  // return index of key if found
  return mid1
}
if (arr[mid2] === key) {
  // return index of key if found
  return mid2
}

// since the key is not found at mid,
// check in which region it is present
// and repeat the Search operation
// in that region
if (key &amp;lt; arr[mid1]) {
  // the key lies in between low and mid1
  return ternarySearchRecursive(arr, key, low, mid1 - 1)
} else if (key &amp;gt; arr[mid2]) {
  // the key lies in between mid2 and high
  return ternarySearchRecursive(arr, key, mid2 + 1, high)
} else {
  // the key lies in between mid1 and mid2
  return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} else {
// if low &amp;gt; high =&amp;gt; we have searched the whole array without finding the item
return -1
}
}&lt;/p&gt;
&lt;p&gt;function ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {
while (high &amp;gt;= low) {
// find the mid1 and mid2
const mid1 = Math.floor(low + (high - low) / 3)
const mid2 = Math.floor(high - (high - low) / 3)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// check if key is found at any mid
if (arr[mid1] === key) {
  // return index of key if found
  return mid1
}
if (arr[mid2] === key) {
  // return index of key if found
  return mid2
}

// since the key is not found at mid,
// check in which region it is present
// and repeat the Search operation
// in that region
if (key &amp;lt; arr[mid1]) {
  // the key lies in between low and mid1
  high = mid1 - 1
} else if (key &amp;gt; arr[mid2]) {
  // the key lies in between mid2 and high
  low = mid2 + 1
} else {
  // the key lies in between mid1 and mid2
  low = mid1 + 1
  high = mid2 - 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
// the key was not found
return -1
}&lt;/p&gt;
&lt;p&gt;export { ternarySearchRecursive, ternarySearchIterative }&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/binarysearch.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/binarysearch.test_js_/</guid>
      <description>&lt;p&gt;import { binarySearchIterative, binarySearchRecursive } from &amp;lsquo;../BinarySearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const stringArr = [
&amp;lsquo;Alpha&amp;rsquo;,
&amp;lsquo;Bravo&amp;rsquo;,
&amp;lsquo;Charlie&amp;rsquo;,
&amp;lsquo;Delta&amp;rsquo;,
&amp;lsquo;Echo&amp;rsquo;,
&amp;lsquo;Foxtrot&amp;rsquo;,
&amp;lsquo;Golf&amp;rsquo;,
&amp;lsquo;Hotel&amp;rsquo;,
&amp;lsquo;India&amp;rsquo;,
&amp;lsquo;Juliet&amp;rsquo;,
&amp;lsquo;Kilo&amp;rsquo;,
&amp;lsquo;Lima&amp;rsquo;,
&amp;lsquo;Mike&amp;rsquo;,
&amp;lsquo;November&amp;rsquo;,
&amp;lsquo;Oscar&amp;rsquo;,
&amp;lsquo;Papa&amp;rsquo;,
&amp;lsquo;Quebec&amp;rsquo;,
&amp;lsquo;Romeo&amp;rsquo;,
&amp;lsquo;Sierra&amp;rsquo;,
&amp;lsquo;Tango&amp;rsquo;,
&amp;lsquo;Uniform&amp;rsquo;,
&amp;lsquo;Victor&amp;rsquo;,
&amp;lsquo;Whiskey&amp;rsquo;,
&amp;lsquo;X-Ray&amp;rsquo;,
&amp;lsquo;Yankee&amp;rsquo;,
&amp;lsquo;Zulu&amp;rsquo;
]&lt;/p&gt;
&lt;p&gt;describe(&amp;lsquo;Binary Search&amp;rsquo;, () =&amp;gt; {
const funcs = [binarySearchIterative, binarySearchRecursive]
for (const func of funcs) {
test(&amp;rsquo;expect to return the index of the item in the array&amp;rsquo;, () =&amp;gt; {
expect(func(arr, 3)).toBe(2)
})
test(&amp;rsquo;expect to return -1 if not in array&amp;rsquo;, () =&amp;gt; {
expect(func(arr, 11)).toBe(-1)
})
test(&amp;rsquo;expect to return the index of the item in the array&amp;rsquo;, () =&amp;gt; {
expect(func(stringArr, &amp;lsquo;Charlie&amp;rsquo;)).toBe(2)
})
test(&amp;rsquo;expect to return -1 if not in array&amp;rsquo;, () =&amp;gt; {
expect(func(stringArr, &amp;lsquo;Zoft&amp;rsquo;)).toBe(-1)
})
}
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { binarySearchIterative, binarySearchRecursive } from &amp;lsquo;../BinarySearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const stringArr = [
&amp;lsquo;Alpha&amp;rsquo;,
&amp;lsquo;Bravo&amp;rsquo;,
&amp;lsquo;Charlie&amp;rsquo;,
&amp;lsquo;Delta&amp;rsquo;,
&amp;lsquo;Echo&amp;rsquo;,
&amp;lsquo;Foxtrot&amp;rsquo;,
&amp;lsquo;Golf&amp;rsquo;,
&amp;lsquo;Hotel&amp;rsquo;,
&amp;lsquo;India&amp;rsquo;,
&amp;lsquo;Juliet&amp;rsquo;,
&amp;lsquo;Kilo&amp;rsquo;,
&amp;lsquo;Lima&amp;rsquo;,
&amp;lsquo;Mike&amp;rsquo;,
&amp;lsquo;November&amp;rsquo;,
&amp;lsquo;Oscar&amp;rsquo;,
&amp;lsquo;Papa&amp;rsquo;,
&amp;lsquo;Quebec&amp;rsquo;,
&amp;lsquo;Romeo&amp;rsquo;,
&amp;lsquo;Sierra&amp;rsquo;,
&amp;lsquo;Tango&amp;rsquo;,
&amp;lsquo;Uniform&amp;rsquo;,
&amp;lsquo;Victor&amp;rsquo;,
&amp;lsquo;Whiskey&amp;rsquo;,
&amp;lsquo;X-Ray&amp;rsquo;,
&amp;lsquo;Yankee&amp;rsquo;,
&amp;lsquo;Zulu&amp;rsquo;
]&lt;/p&gt;
&lt;p&gt;describe(&amp;lsquo;Binary Search&amp;rsquo;, () =&amp;gt; {
const funcs = [binarySearchIterative, binarySearchRecursive]
for (const func of funcs) {
test(&amp;rsquo;expect to return the index of the item in the array&amp;rsquo;, () =&amp;gt; {
expect(func(arr, 3)).toBe(2)
})
test(&amp;rsquo;expect to return -1 if not in array&amp;rsquo;, () =&amp;gt; {
expect(func(arr, 11)).toBe(-1)
})
test(&amp;rsquo;expect to return the index of the item in the array&amp;rsquo;, () =&amp;gt; {
expect(func(stringArr, &amp;lsquo;Charlie&amp;rsquo;)).toBe(2)
})
test(&amp;rsquo;expect to return -1 if not in array&amp;rsquo;, () =&amp;gt; {
expect(func(stringArr, &amp;lsquo;Zoft&amp;rsquo;)).toBe(-1)
})
}
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/exponentialsearch.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/exponentialsearch.test_js_/</guid>
      <description>&lt;p&gt;import { exponentialSearch } from &amp;lsquo;../ExponentialSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is 6 where the value = 78&amp;rsquo;, () =&amp;gt; {
const arr = [2, 3, 4, 10, 40, 65, 78, 100]
const value = 78
const result = exponentialSearch(arr, arr.length, value)
expect(result).toEqual(6)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is -1 where the value = 178&amp;rsquo;, () =&amp;gt; {
const arr = [2, 3, 4, 10, 40, 65, 78, 100]
const value = 178
const result = exponentialSearch(arr, arr.length, value)
expect(result).toEqual(-1)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { exponentialSearch } from &amp;lsquo;../ExponentialSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is 6 where the value = 78&amp;rsquo;, () =&amp;gt; {
const arr = [2, 3, 4, 10, 40, 65, 78, 100]
const value = 78
const result = exponentialSearch(arr, arr.length, value)
expect(result).toEqual(6)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is -1 where the value = 178&amp;rsquo;, () =&amp;gt; {
const arr = [2, 3, 4, 10, 40, 65, 78, 100]
const value = 178
const result = exponentialSearch(arr, arr.length, value)
expect(result).toEqual(-1)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/fibonaccisearch.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/fibonaccisearch.test_js_/</guid>
      <description>&lt;p&gt;import { fibonacciSearch } from &amp;lsquo;../FibonacciSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;fibonacciSearch([10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100], 90, arr.length) =&amp;gt; 9&amp;rsquo;, () =&amp;gt; {
const arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
const target = 90
const res = fibonacciSearch(arr, target, arr.length)
expect(res).toEqual(9)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;fibonacciSearch([1, 11, 55, 56, 78, 82, 104], 104, arr.length) =&amp;gt; 6&amp;rsquo;, () =&amp;gt; {
const arr = [1, 11, 55, 56, 78, 82, 104]
const target = 104
const res = fibonacciSearch(arr, target, arr.length)
expect(res).toEqual(6)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { fibonacciSearch } from &amp;lsquo;../FibonacciSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;fibonacciSearch([10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100], 90, arr.length) =&amp;gt; 9&amp;rsquo;, () =&amp;gt; {
const arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
const target = 90
const res = fibonacciSearch(arr, target, arr.length)
expect(res).toEqual(9)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;fibonacciSearch([1, 11, 55, 56, 78, 82, 104], 104, arr.length) =&amp;gt; 6&amp;rsquo;, () =&amp;gt; {
const arr = [1, 11, 55, 56, 78, 82, 104]
const target = 104
const res = fibonacciSearch(arr, target, arr.length)
expect(res).toEqual(6)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;fibonacciSearch([40, 45, 50, 80, 82, 85, 90, 100]. 190, arr.length) =&amp;gt; -1&amp;rsquo;, () =&amp;gt; {
const arr = [40, 45, 50, 80, 82, 85, 90, 100]
const target = 190
const res = fibonacciSearch(arr, target, arr.length)
expect(res).toEqual(-1)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/interpolationsearch.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/interpolationsearch.test_js_/</guid>
      <description>&lt;p&gt;import { interpolationSearch } from &amp;lsquo;../InterpolationSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;interpolationSearch([2, 6, 8, 14, 122, 169], 144) =&amp;gt; -1&amp;rsquo;, () =&amp;gt; {
const array = [2, 6, 8, 14, 122, 169]
const key = 144
const res = interpolationSearch(array, key)
expect(res).toEqual(-1)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;interpolationSearch([2, 6, 8, 14, 122, 169], 122) =&amp;gt; 4&amp;rsquo;, () =&amp;gt; {
const array = [2, 6, 8, 14, 122, 169]
const key = 122
const res = interpolationSearch(array, key)
expect(res).toEqual(4)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { interpolationSearch } from &amp;lsquo;../InterpolationSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;interpolationSearch([2, 6, 8, 14, 122, 169], 144) =&amp;gt; -1&amp;rsquo;, () =&amp;gt; {
const array = [2, 6, 8, 14, 122, 169]
const key = 144
const res = interpolationSearch(array, key)
expect(res).toEqual(-1)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;interpolationSearch([2, 6, 8, 14, 122, 169], 122) =&amp;gt; 4&amp;rsquo;, () =&amp;gt; {
const array = [2, 6, 8, 14, 122, 169]
const key = 122
const res = interpolationSearch(array, key)
expect(res).toEqual(4)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/jumpsearch.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/jumpsearch.test_js_/</guid>
      <description>&lt;p&gt;import { jumpSearch } from &amp;lsquo;../JumpSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;jumpSearch([0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90], 77) =&amp;gt; 10&amp;rsquo;, () =&amp;gt; {
const arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]
const res = jumpSearch(arr, 77)
expect(res).toEqual(10)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;jumpSearch([11, 12, 15, 65, 78, 90], 4) =&amp;gt; -1&amp;rsquo;, () =&amp;gt; {
const arr = [11, 12, 15, 65, 78, 90]
const res = jumpSearch(arr, 4)
expect(res).toEqual(-1)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { jumpSearch } from &amp;lsquo;../JumpSearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;jumpSearch([0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90], 77) =&amp;gt; 10&amp;rsquo;, () =&amp;gt; {
const arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]
const res = jumpSearch(arr, 77)
expect(res).toEqual(10)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;jumpSearch([11, 12, 15, 65, 78, 90], 4) =&amp;gt; -1&amp;rsquo;, () =&amp;gt; {
const arr = [11, 12, 15, 65, 78, 90]
const res = jumpSearch(arr, 4)
expect(res).toEqual(-1)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;jumpSearch([11, 12, 15, 65, 78, 90], 11) =&amp;gt; 0&amp;rsquo;, () =&amp;gt; {
const arr = [11, 12, 15, 65, 78, 90]
const res = jumpSearch(arr, 11)
expect(res).toEqual(0)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/slidingwindow.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/slidingwindow.test_js_/</guid>
      <description>&lt;p&gt;import { slidingWindow } from &amp;lsquo;../SlidingWindow&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;expect to return the largest sum of sequence in the array&amp;rsquo;, () =&amp;gt; {
const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 2)
expect(sum).toBe(10)
})&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;expect to return the largest sum of sequence in the array&amp;rsquo;, () =&amp;gt; {
const sum = slidingWindow([5, 2, 6, 9], 3)
expect(sum).toBe(17)
})&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;expect to return null when the sequence size is larger then the array length&amp;rsquo;, () =&amp;gt; {
const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 15)
expect(sum).toBe(null)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { slidingWindow } from &amp;lsquo;../SlidingWindow&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;expect to return the largest sum of sequence in the array&amp;rsquo;, () =&amp;gt; {
const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 2)
expect(sum).toBe(10)
})&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;expect to return the largest sum of sequence in the array&amp;rsquo;, () =&amp;gt; {
const sum = slidingWindow([5, 2, 6, 9], 3)
expect(sum).toBe(17)
})&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;expect to return null when the sequence size is larger then the array length&amp;rsquo;, () =&amp;gt; {
const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 15)
expect(sum).toBe(null)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/ternarysearch.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/ternarysearch.test_js_/</guid>
      <description>&lt;p&gt;import { ternarySearchRecursive, ternarySearchIterative } from &amp;lsquo;../TernarySearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)
expect(indexNumber).toBe(2)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)
expect(indexNumber).toBe(7)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)
expect(indexNumber).toBe(-1)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { ternarySearchRecursive, ternarySearchIterative } from &amp;lsquo;../TernarySearch&amp;rsquo;&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)
expect(indexNumber).toBe(2)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)
expect(indexNumber).toBe(7)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)
expect(indexNumber).toBe(-1)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a number in an array of numbers:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 12)
expect(indexNumber).toBe(-1)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a string in an array of strings:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([&amp;lsquo;Ali&amp;rsquo;, &amp;lsquo;Cathrynli&amp;rsquo;, &amp;lsquo;Josuke&amp;rsquo;, &amp;lsquo;Thomas&amp;rsquo;], &amp;lsquo;Cathrynli&amp;rsquo;)
expect(indexNumber).toBe(1)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a string in an array of strings:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([&amp;lsquo;Ali&amp;rsquo;, &amp;lsquo;Cathrynli&amp;rsquo;, &amp;lsquo;Josuke&amp;rsquo;, &amp;lsquo;Thomas&amp;rsquo;], &amp;lsquo;Josuke&amp;rsquo;)
expect(indexNumber).toBe(2)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should return the index of a string in an array of strings:&amp;rsquo;, () =&amp;gt; {
const indexNumber = ternarySearchRecursive([&amp;lsquo;Ali&amp;rsquo;, &amp;lsquo;Cathrynli&amp;rsquo;, &amp;lsquo;Josuke&amp;rsquo;, &amp;lsquo;Thomas&amp;rsquo;], &amp;lsquo;Angela&amp;rsquo;)
expect(indexNumber).toBe(-1)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/test/unionfind.test_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/test/unionfind.test_js_/</guid>
      <description>&lt;p&gt;import { UnionFind } from &amp;lsquo;../UnionFind&amp;rsquo;&lt;/p&gt;
&lt;p&gt;const uf = new UnionFind(5)&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should expose .size():&amp;rsquo;, () =&amp;gt; {
const size = uf.size()
expect(size).toBe(5)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should do .union(num1, num2):&amp;rsquo;, () =&amp;gt; {
uf.union(1, 2)
uf.union(3, 4)
uf.union(0, 4)
expect(uf.connected(1, 2)).toBe(true)
expect(uf.connected(1, 2)).toBe(true)&lt;/p&gt;
&lt;p&gt;expect(uf.connected(3, 4)).toBe(true)
expect(uf.connected(3, 0)).toBe(true)
expect(uf.connected(4, 0)).toBe(true)&lt;/p&gt;
&lt;p&gt;expect(uf.connected(1, 3)).toBe(false)
expect(uf.connected(1, 4)).toBe(false)
expect(uf.connected(1, 0)).toBe(false)
expect(uf.connected(2, 3)).toBe(false)
expect(uf.connected(2, 4)).toBe(false)
expect(uf.connected(2, 0)).toBe(false)
})&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;.count(), should return the number of disparate groups:&amp;rsquo;, () =&amp;gt; {
expect(uf.count()).toBe(2)
})&lt;/p&gt;</description>
      <content>&lt;p&gt;import { UnionFind } from &amp;lsquo;../UnionFind&amp;rsquo;&lt;/p&gt;
&lt;p&gt;const uf = new UnionFind(5)&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should expose .size():&amp;rsquo;, () =&amp;gt; {
const size = uf.size()
expect(size).toBe(5)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should do .union(num1, num2):&amp;rsquo;, () =&amp;gt; {
uf.union(1, 2)
uf.union(3, 4)
uf.union(0, 4)
expect(uf.connected(1, 2)).toBe(true)
expect(uf.connected(1, 2)).toBe(true)&lt;/p&gt;
&lt;p&gt;expect(uf.connected(3, 4)).toBe(true)
expect(uf.connected(3, 0)).toBe(true)
expect(uf.connected(4, 0)).toBe(true)&lt;/p&gt;
&lt;p&gt;expect(uf.connected(1, 3)).toBe(false)
expect(uf.connected(1, 4)).toBe(false)
expect(uf.connected(1, 0)).toBe(false)
expect(uf.connected(2, 3)).toBe(false)
expect(uf.connected(2, 4)).toBe(false)
expect(uf.connected(2, 0)).toBe(false)
})&lt;/p&gt;
&lt;p&gt;test(&amp;rsquo;.count(), should return the number of disparate groups:&amp;rsquo;, () =&amp;gt; {
expect(uf.count()).toBe(2)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should check if two components are connected, .connected(num1, num2):&amp;rsquo;, () =&amp;gt; {
expect(uf.connected(1, 2)).toBe(true)
expect(uf.connected(1, 3)).toBe(false)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should find the root of the tree in which the given element lives, .find(num):&amp;rsquo;, () =&amp;gt; {
expect(uf.find(1)).toBe(1)
expect(uf.find(2)).toBe(1)
expect(uf.find(3)).toBe(3)
expect(uf.find(4)).toBe(3)
expect(uf.find(0)).toBe(3)
})&lt;/p&gt;
&lt;p&gt;test(&amp;lsquo;should always change the id of the smaller tree and preserve the id of the larger one&amp;rsquo;, () =&amp;gt; {
uf.union(2, 3)
expect(uf.count()).toBe(1)
expect(uf.find(0)).toBe(3)
expect(uf.find(1)).toBe(3)
expect(uf.find(2)).toBe(3)
expect(uf.find(3)).toBe(3)
expect(uf.find(4)).toBe(3)
})&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title></title>
      <link>//localhost:1313/posts/algorithms/searchalgorithm/unionfind_js_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/posts/algorithms/searchalgorithm/unionfind_js_/</guid>
      <description>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;union find data structure for javascript&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;In computer science, a disjoint-set data structure, also called a union–find data structure or merge–find set,&lt;/li&gt;
&lt;li&gt;is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition&lt;/li&gt;
&lt;li&gt;of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),&lt;/li&gt;
&lt;li&gt;and finding a representative member of a set.&lt;/li&gt;
&lt;li&gt;The last operation allows to find out efficiently if any two elements are in the same or different sets.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Disjoint-set data structures play a key role in Kruskal&amp;rsquo;s algorithm for finding the minimum spanning tree of a graph.&lt;/li&gt;
&lt;li&gt;The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.&lt;/li&gt;
&lt;li&gt;In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,&lt;/li&gt;
&lt;li&gt;especially for register allocation problems.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;you can learn more on disjoint-set / union–find data structure at &lt;a href=&#34;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&#34;&gt;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&lt;/a&gt;
*/
function UnionFind (n, key) {
if (!(this instanceof UnionFind)) return new UnionFind(n)
if (key &amp;amp;&amp;amp; typeof key !== &amp;lsquo;function&amp;rsquo;) {
throw new Error(&amp;lsquo;key has to be a function or else left undefined&amp;rsquo;)
}
let cnt, length
// init Union Find with number of distinct groups. Each group will be referred to as index of the array of size &amp;lsquo;size&amp;rsquo; starting at 0.
// Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.
key = key || function (a) { return a }
cnt = length = n
const id = new Array(n)
const sz = new Array(n)
for (let i = 0; i &amp;lt; n; i++) {
id[i] = i
sz[i] = 1
}
// Returns the number of elements of uf object.
this.size = function () {
return length
}
// Returns the number of distinct groups left inside the object.
this.count = function () {
return cnt
}
// Return the root (value) of the group in which p is.
this.find = function (p) {
p = key(p)
while (p !== id[p]) {
id[p] = id[id[p]]
p = id[p]
}
return p
}
// Returns true if p and p are both in same group, false otherwise.
this.connected = function (p, q) {
p = key(p)
q = key(q)
ensureIndexWithinBounds(p, q)
return this.find(p) === this.find(q)
}
// Combine elements in groups p and q into a single group. In other words connect the two groups.
this.union = function (p, q) {
p = key(p)
q = key(q)
ensureIndexWithinBounds(p, q)
const i = this.find(p)
const j = this.find(q)
if (i === j) return
if (sz[i] &amp;lt; sz[j]) {
id[i] = j; sz[j] += sz[i]
} else {
id[j] = i; sz[i] += sz[j]
}
cnt&amp;ndash;
}
function ensureIndexWithinBounds (args) {
for (let i = arguments.length - 1; i &amp;gt;= 0; i&amp;ndash;) {
const p = arguments[i]
if (p &amp;gt;= length) throw new Error(&amp;lsquo;Index out of bounds. The maximum index can be length-1&amp;rsquo;)
}
}
}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export { UnionFind }&lt;/p&gt;</description>
      <content>&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;union find data structure for javascript&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;In computer science, a disjoint-set data structure, also called a union–find data structure or merge–find set,&lt;/li&gt;
&lt;li&gt;is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition&lt;/li&gt;
&lt;li&gt;of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),&lt;/li&gt;
&lt;li&gt;and finding a representative member of a set.&lt;/li&gt;
&lt;li&gt;The last operation allows to find out efficiently if any two elements are in the same or different sets.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Disjoint-set data structures play a key role in Kruskal&amp;rsquo;s algorithm for finding the minimum spanning tree of a graph.&lt;/li&gt;
&lt;li&gt;The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.&lt;/li&gt;
&lt;li&gt;In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,&lt;/li&gt;
&lt;li&gt;especially for register allocation problems.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;you can learn more on disjoint-set / union–find data structure at &lt;a href=&#34;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&#34;&gt;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&lt;/a&gt;
*/
function UnionFind (n, key) {
if (!(this instanceof UnionFind)) return new UnionFind(n)
if (key &amp;amp;&amp;amp; typeof key !== &amp;lsquo;function&amp;rsquo;) {
throw new Error(&amp;lsquo;key has to be a function or else left undefined&amp;rsquo;)
}
let cnt, length
// init Union Find with number of distinct groups. Each group will be referred to as index of the array of size &amp;lsquo;size&amp;rsquo; starting at 0.
// Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.
key = key || function (a) { return a }
cnt = length = n
const id = new Array(n)
const sz = new Array(n)
for (let i = 0; i &amp;lt; n; i++) {
id[i] = i
sz[i] = 1
}
// Returns the number of elements of uf object.
this.size = function () {
return length
}
// Returns the number of distinct groups left inside the object.
this.count = function () {
return cnt
}
// Return the root (value) of the group in which p is.
this.find = function (p) {
p = key(p)
while (p !== id[p]) {
id[p] = id[id[p]]
p = id[p]
}
return p
}
// Returns true if p and p are both in same group, false otherwise.
this.connected = function (p, q) {
p = key(p)
q = key(q)
ensureIndexWithinBounds(p, q)
return this.find(p) === this.find(q)
}
// Combine elements in groups p and q into a single group. In other words connect the two groups.
this.union = function (p, q) {
p = key(p)
q = key(q)
ensureIndexWithinBounds(p, q)
const i = this.find(p)
const j = this.find(q)
if (i === j) return
if (sz[i] &amp;lt; sz[j]) {
id[i] = j; sz[j] += sz[i]
} else {
id[j] = i; sz[i] += sz[j]
}
cnt&amp;ndash;
}
function ensureIndexWithinBounds (args) {
for (let i = arguments.length - 1; i &amp;gt;= 0; i&amp;ndash;) {
const p = arguments[i]
if (p &amp;gt;= length) throw new Error(&amp;lsquo;Index out of bounds. The maximum index can be length-1&amp;rsquo;)
}
}
}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export { UnionFind }&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
