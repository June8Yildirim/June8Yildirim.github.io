<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title> :: Cuneyt Yildirim Site</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="/**
union find data structure for javascript In computer science, a disjoint-set data structure, also called a union–find data structure or merge–find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. The last operation allows to find out efficiently if any two elements are in the same or different sets. Disjoint-set data structures play a key role in Kruskal&rsquo;s algorithm for finding the minimum spanning tree of a graph. The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms. In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers, especially for register allocation problems. you can learn more on disjoint-set / union–find data structure at https://en.wikipedia.org/wiki/Disjoint-set_data_structure */ function UnionFind (n, key) { if (!(this instanceof UnionFind)) return new UnionFind(n) if (key &amp;&amp; typeof key !== &lsquo;function&rsquo;) { throw new Error(&lsquo;key has to be a function or else left undefined&rsquo;) } let cnt, length // init Union Find with number of distinct groups. Each group will be referred to as index of the array of size &lsquo;size&rsquo; starting at 0. // Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}. key = key || function (a) { return a } cnt = length = n const id = new Array(n) const sz = new Array(n) for (let i = 0; i &lt; n; i&#43;&#43;) { id[i] = i sz[i] = 1 } // Returns the number of elements of uf object. this.size = function () { return length } // Returns the number of distinct groups left inside the object. this.count = function () { return cnt } // Return the root (value) of the group in which p is. this.find = function (p) { p = key(p) while (p !== id[p]) { id[p] = id[id[p]] p = id[p] } return p } // Returns true if p and p are both in same group, false otherwise. this.connected = function (p, q) { p = key(p) q = key(q) ensureIndexWithinBounds(p, q) return this.find(p) === this.find(q) } // Combine elements in groups p and q into a single group. In other words connect the two groups. this.union = function (p, q) { p = key(p) q = key(q) ensureIndexWithinBounds(p, q) const i = this.find(p) const j = this.find(q) if (i === j) return if (sz[i] &lt; sz[j]) { id[i] = j; sz[j] &#43;= sz[i] } else { id[j] = i; sz[i] &#43;= sz[j] } cnt&ndash; } function ensureIndexWithinBounds (args) { for (let i = arguments.length - 1; i &gt;= 0; i&ndash;) { const p = arguments[i] if (p &gt;= length) throw new Error(&lsquo;Index out of bounds. The maximum index can be length-1&rsquo;) } } } export { UnionFind }
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="//localhost:1313/posts/algorithms/searchalgorithm/unionfind_js_/" />







  
  
  
  
  
  <link rel="stylesheet" href="//localhost:1313/styles.css">







  <link rel="shortcut icon" href="//localhost:1313/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="//localhost:1313/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="">
<meta property="og:description" content="/**
union find data structure for javascript In computer science, a disjoint-set data structure, also called a union–find data structure or merge–find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. The last operation allows to find out efficiently if any two elements are in the same or different sets. Disjoint-set data structures play a key role in Kruskal&rsquo;s algorithm for finding the minimum spanning tree of a graph. The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms. In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers, especially for register allocation problems. you can learn more on disjoint-set / union–find data structure at https://en.wikipedia.org/wiki/Disjoint-set_data_structure */ function UnionFind (n, key) { if (!(this instanceof UnionFind)) return new UnionFind(n) if (key &amp;&amp; typeof key !== &lsquo;function&rsquo;) { throw new Error(&lsquo;key has to be a function or else left undefined&rsquo;) } let cnt, length // init Union Find with number of distinct groups. Each group will be referred to as index of the array of size &lsquo;size&rsquo; starting at 0. // Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}. key = key || function (a) { return a } cnt = length = n const id = new Array(n) const sz = new Array(n) for (let i = 0; i &lt; n; i&#43;&#43;) { id[i] = i sz[i] = 1 } // Returns the number of elements of uf object. this.size = function () { return length } // Returns the number of distinct groups left inside the object. this.count = function () { return cnt } // Return the root (value) of the group in which p is. this.find = function (p) { p = key(p) while (p !== id[p]) { id[p] = id[id[p]] p = id[p] } return p } // Returns true if p and p are both in same group, false otherwise. this.connected = function (p, q) { p = key(p) q = key(q) ensureIndexWithinBounds(p, q) return this.find(p) === this.find(q) } // Combine elements in groups p and q into a single group. In other words connect the two groups. this.union = function (p, q) { p = key(p) q = key(q) ensureIndexWithinBounds(p, q) const i = this.find(p) const j = this.find(q) if (i === j) return if (sz[i] &lt; sz[j]) { id[i] = j; sz[j] &#43;= sz[i] } else { id[j] = i; sz[i] &#43;= sz[j] } cnt&ndash; } function ensureIndexWithinBounds (args) { for (let i = arguments.length - 1; i &gt;= 0; i&ndash;) { const p = arguments[i] if (p &gt;= length) throw new Error(&lsquo;Index out of bounds. The maximum index can be length-1&rsquo;) } } } export { UnionFind }
" />
<meta property="og:url" content="//localhost:1313/posts/algorithms/searchalgorithm/unionfind_js_/" />
<meta property="og:site_name" content="Cuneyt Yildirim Site" />

  
    <meta property="og:image" content="//localhost:1313/img/favicon/orange.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">














  


</head>
<body class="orange">




<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Cuneyt Yildirim
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/posts">Posts</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/posts" >Posts</a></li>
        
      
        
          <li><a href="/showcase" >Showcase</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="//localhost:1313/posts/algorithms/searchalgorithm/unionfind_js_/"></a>
  </h1>
  <div class="post-meta">
    
</div>

  
  



  

  <div class="post-content"><div>
        <p>/**</p>
<ul>
<li>union find data structure for javascript</li>
<li></li>
<li>In computer science, a disjoint-set data structure, also called a union–find data structure or merge–find set,</li>
<li>is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition</li>
<li>of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),</li>
<li>and finding a representative member of a set.</li>
<li>The last operation allows to find out efficiently if any two elements are in the same or different sets.</li>
<li></li>
<li>Disjoint-set data structures play a key role in Kruskal&rsquo;s algorithm for finding the minimum spanning tree of a graph.</li>
<li>The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.</li>
<li>In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,</li>
<li>especially for register allocation problems.</li>
<li></li>
<li>you can learn more on disjoint-set / union–find data structure at <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>
*/
function UnionFind (n, key) {
if (!(this instanceof UnionFind)) return new UnionFind(n)
if (key &amp;&amp; typeof key !== &lsquo;function&rsquo;) {
throw new Error(&lsquo;key has to be a function or else left undefined&rsquo;)
}
let cnt, length
// init Union Find with number of distinct groups. Each group will be referred to as index of the array of size &lsquo;size&rsquo; starting at 0.
// Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.
key = key || function (a) { return a }
cnt = length = n
const id = new Array(n)
const sz = new Array(n)
for (let i = 0; i &lt; n; i++) {
id[i] = i
sz[i] = 1
}
// Returns the number of elements of uf object.
this.size = function () {
return length
}
// Returns the number of distinct groups left inside the object.
this.count = function () {
return cnt
}
// Return the root (value) of the group in which p is.
this.find = function (p) {
p = key(p)
while (p !== id[p]) {
id[p] = id[id[p]]
p = id[p]
}
return p
}
// Returns true if p and p are both in same group, false otherwise.
this.connected = function (p, q) {
p = key(p)
q = key(q)
ensureIndexWithinBounds(p, q)
return this.find(p) === this.find(q)
}
// Combine elements in groups p and q into a single group. In other words connect the two groups.
this.union = function (p, q) {
p = key(p)
q = key(q)
ensureIndexWithinBounds(p, q)
const i = this.find(p)
const j = this.find(q)
if (i === j) return
if (sz[i] &lt; sz[j]) {
id[i] = j; sz[j] += sz[i]
} else {
id[j] = i; sz[i] += sz[j]
}
cnt&ndash;
}
function ensureIndexWithinBounds (args) {
for (let i = arguments.length - 1; i &gt;= 0; i&ndash;) {
const p = arguments[i]
if (p &gt;= length) throw new Error(&lsquo;Index out of bounds. The maximum index can be length-1&rsquo;)
}
}
}</li>
</ul>
<p>export { UnionFind }</p>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="//localhost:1313/posts/algorithms/searchalgorithm/test/unionfind.test_js_/">
                <span class="button__icon">←</span>
                <span class="button__text"></span>
            </a>
        </span>
        
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/mirus-ua/hugo-theme-re-terminal" target="_blank">Theme</a> made by <a href="https://github.com/mirus-ua" target="_blank">Mirus</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>








  
</div>

</body>
</html>
